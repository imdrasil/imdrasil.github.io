crystal_doc_search_index_callback({"repository_name":"github.com/imdrasil/ifrit","body":"# Ifrit [![Build Status](https://travis-ci.org/imdrasil/ifrit.svg)](https://travis-ci.org/imdrasil/ifrit) [![Latest Release](https://img.shields.io/github/release/imdrasil/ifrit.svg)](https://github.com/imdrasil/ifrit/releases)\n\nSet of useful classes, patches and hacks. Some of them are not \"good\" enough so be ready to make a deal with **Ifrit**.\n\n## Installation\n\nAdd this to your application's `shard.yml`:\n\n```yaml\ndependencies:\n  ifrit:\n    github: imdrasil/ifrit\n```\n\n## Usage\n\nThis lib provides modular approach so you should specify what exactly you want to require:\n\n```crystal\nrequire \"ifrit/core\" # for basic methods\nrequire \"ifrit/inheritable_json\" # for particular pact like InheritableJSON\nrequire \"ifrit\" # to load everything\n```\n\n### Pacts\n\n#### Core\n\n```crystal\nrequire \"ifrit/core\"\n```\n\nIncludes next methods:\n\n- `#blank?` - behaves same way as rails one;\n- `#present?` - opposite to `#blank?`;\n- `#to_bool` - parses string or integer for boolean value interpretation.\n\n#### Converter\n\n```crystal\nrequire \"ifrit/converter\"\n\nIfrit.typed_hash({\"a\" => 1, \"b\" => \"asd\"}, String, String | Int32) # Hash(String, String | Int32)\n```\n\n#### Symbol Table\n\n```crystal\nrequire \"ifrit/symbol_table\"\n\ninclude SymbolTable::Methods\n\na = s(:asd)\n# ...\n\"asd\".to_sym # :asd\n```\n\n#### Inheritable JSON\n\n```crystal\nrequire \"ifrit/inheritable_json\"\n\nclass A\n  extend InheritableJSON\n\n  json_mapping({\n    a:               String,\n    b:               {type: Int32},\n    nillable_field1: {type: String?},\n    nillable_field2: {type: String?},\n  })\nend\n\nprivate class B < A\nend\n\nprivate class C < B\n  json_mapping({\n    with_default: {type: String?, default: \"default\"},\n  })\nend\n```\n\n#### Hash with indifferent access\n\n```crystal\nrequire \"ifrit/hash_with_indifferent_access\"\n\nh = HashWithIndifferentAccess(Int32).new\nh[:asd] = 23\nh[\"asd\"] # 23\n```\n\n## Contributing\n\nBefore start working on any new feature please create an issue to discuss it.\n\n1. Fork it ( https://github.com/imdrasil/ifrit/fork )\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am 'Add some feature')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n## Contributors\n\n- [imdrasil](https://github.com/imdrasil) Roman Kalnytskyi - creator, maintainer\n","program":{"html_id":"github.com/imdrasil/ifrit/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/imdrasil/ifrit","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/imdrasil/ifrit/Array","path":"Array.html","kind":"class","full_name":"Array(T)","name":"Array","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/imdrasil/ifrit/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/imdrasil/ifrit/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":74,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"An `Array` is an ordered, integer-indexed collection of objects of type T.\n\nArray indexing starts at 0. A negative index is assumed to be\nrelative to the end of the array: -1 indicates the last element,\n-2 is the next to last element, and so on.\n\nAn `Array` can be created using the usual `new` method (several are provided), or with an array literal:\n\n```\nArray(Int32).new  # => []\n[1, 2, 3]         # Array(Int32)\n[1, \"hello\", 'x'] # Array(Int32 | String | Char)\n```\n\nAn `Array` can have mixed types, meaning T will be a union of types, but these are determined\nwhen the array is created, either by specifying T or by using an array literal. In the latter\ncase, T will be set to the union of the array literal elements' types.\n\nWhen creating an empty array you must always specify T:\n\n```\n[] of Int32 # same as Array(Int32)\n[]          # syntax error\n```\n\nAn `Array` is implemented using an internal buffer of some capacity\nand is reallocated when elements are pushed to it when more capacity\nis needed. This is normally known as a [dynamic array](http://en.wikipedia.org/wiki/Dynamic_array).\n\nYou can use a special array literal syntax with other types too, as long as they define an argless\n`new` method and a `<<` method. `Set` is one such type:\n\n```\nset = Set{1, 2, 3} # => Set{1, 2, 3}\nset.class          # => Set(Int32)\n```\n\nThe above is the same as this:\n\n```\nset = Set(typeof(1, 2, 3)).new\nset << 1\nset << 2\nset << 3\n```","summary":"<p>An <code><a href=\"Array.html\">Array</a></code> is an ordered, integer-indexed collection of objects of type T.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L76","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L76","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"size == 0"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/BitArray","path":"BitArray.html","kind":"struct","full_name":"BitArray","name":"BitArray","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":88,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L88","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L88","def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L90","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L90","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"flag = true\nsize.times do |i|\n  if self[i]\n    flag = false\n    break\n  end\nend\nflag\n"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Hash","path":"Hash.html","kind":"class","full_name":"Hash(K, V)","name":"Hash","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/imdrasil/ifrit/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":81,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/imdrasil/ifrit/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/imdrasil/ifrit/HashWithIndifferentAccess","kind":"class","full_name":"HashWithIndifferentAccess(V)","name":"HashWithIndifferentAccess"}],"including_types":[],"namespace":null,"doc":"A `Hash` represents a mapping of keys to values.\n\nSee the [official docs](http://crystal-lang.org/docs/syntax_and_semantics/literals/hash.html) for the basics.","summary":"<p>A <code><a href=\"Hash.html\">Hash</a></code> represents a mapping of keys to values.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L83","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L83","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"size == 0"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/HashWithIndifferentAccess","path":"HashWithIndifferentAccess.html","kind":"class","full_name":"HashWithIndifferentAccess(V)","name":"HashWithIndifferentAccess","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Hash","kind":"class","full_name":"Hash","name":"Hash"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Hash","kind":"class","full_name":"Hash","name":"Hash"},{"html_id":"github.com/imdrasil/ifrit/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/imdrasil/ifrit/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/hash_with_indifferent_access.cr","line_number":4,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Allows to access values by both `String` and `Symbol` key.","summary":"<p>Allows to access values by both <code><a href=\"String.html\">String</a></code> and <code>Symbol</code> key.</p>","class_methods":[],"constructors":[{"id":"new(hash:Hash)-class-method","html_id":"new(hash:Hash)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":"Hash"}],"args_string":"(hash : Hash)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L5","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L5","def":{"name":"new","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":"Hash"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new_hash = new\nhash.each do |key, value|\n  new_hash[key.to_s] = value\nend\nnew_hash\n"}},{"id":"new(named_tuple:NamedTuple)-class-method","html_id":"new(named_tuple:NamedTuple)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"named_tuple","doc":null,"default_value":"","external_name":"named_tuple","restriction":"NamedTuple"}],"args_string":"(named_tuple : NamedTuple)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L13","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L13","def":{"name":"new","args":[{"name":"named_tuple","doc":null,"default_value":"","external_name":"named_tuple","restriction":"NamedTuple"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new_hash = new\nnamed_tuple.each do |key, value|\n  new_hash[key.to_s] = value\nend\nnew_hash\n"}}],"instance_methods":[{"id":"[]=(key:Symbol,value:V)-instance-method","html_id":"[]=(key:Symbol,value:V)-instance-method","name":"[]=","doc":null,"summary":null,"abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"V"}],"args_string":"(key : Symbol, value : V)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L21","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L21","def":{"name":"[]=","args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"V"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[key.to_s] = value"}},{"id":"delete(key:Symbol)-instance-method","html_id":"delete(key:Symbol)-instance-method","name":"delete","doc":null,"summary":null,"abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"}],"args_string":"(key : Symbol)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L29","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L29","def":{"name":"delete","args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"delete(key.to_s)"}},{"id":"delete(key:Symbol,&block)-instance-method","html_id":"delete(key:Symbol,&amp;block)-instance-method","name":"delete","doc":null,"summary":null,"abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"}],"args_string":"(key : Symbol, &block)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L33","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L33","def":{"name":"delete","args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"Symbol"}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"delete(key.to_s) do |k|\n  yield k\nend"}},{"id":"values_at(*indexes:Symbol)-instance-method","html_id":"values_at(*indexes:Symbol)-instance-method","name":"values_at","doc":null,"summary":null,"abstract":false,"args":[{"name":"indexes","doc":null,"default_value":"","external_name":"indexes","restriction":"Symbol"}],"args_string":"(*indexes : Symbol)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L25","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/hash_with_indifferent_access.cr#L25","def":{"name":"values_at","args":[{"name":"indexes","doc":null,"default_value":"","external_name":"indexes","restriction":"Symbol"}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"indexes.map do |index|\n  self[index.to_s]\nend"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Ifrit","path":"Ifrit.html","kind":"module","full_name":"Ifrit","name":"Ifrit","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"ifrit/version.cr","line_number":1,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/version.cr"},{"filename":"ifrit/converter.cr","line_number":3,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr"},{"filename":"ifrit/inflector.cr","line_number":1,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inflector.cr"},{"filename":"ifrit.cr","line_number":3,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.2\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"render_macros-macro","html_id":"render_macros-macro","name":"render_macros","doc":"Renders convertable macros.\n\nThese convert macros are designed to provide interface for converting hash to exact type \n(e.g. `{\"asd\" => \"asd\"} of String | Int64 => Float32 | Symbol | String` to `String => String`).\nAdds next macros:\n- `%typed_hash` - converts given hash literal to one with given key type (`key`) and value type (`types`); without cycles;\n- `%sym_hash_cast` - is a shortcut for `%typed_hash` for symbol keys;\n- `%str_hash_cast` - is a shortcut for `%typed_hash` for string keys;\n- `%typed_hash_cast` - converts given variable or hash literal to one with given key (`key`) and value (`types`) type;\n- `%sym_hash` - is a shortcut for `%typed_hash_cast` for symbol keys;\n- `%str_hash` - is a shortcut for `%typed_hash_cast` for string keys;\n- `%typed_array_cast` - converts given array variable or array literal to one with given types (`klass`);\n- `%typed_array` - converts given array literal to array with given type (`klass`); without cycles;\n- `%stringify_hash` - calls `#to_s` on keys and converts all values to given type (`klass`);\n\n```\nIfrit.str_hash({:asd => \"qwe\"}, String)\n\nclass Test\n  extend Ifrit\n\n  def some_method\n    str_hash({:asd => \"qwe\"}, String)\n  end\nend\n```","summary":"<p>Renders convertable macros.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L30","def":{"name":"render_macros","args":[],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n# accepts only hash literals\n\n    \n# example: Ifrit.typed_hash(\n{\"a\" => 1, \"b\" => \"b\"}, String, Int32 | String)\n\n    macro typed_hash(hash, key, types)\n      begin\n        \n%hash\n = \n{} of \n\\{\n{key.id}} => \n\\{\n{types.id}}\n        \n\\{% \ntype = key.resolve %}\n        \n\\{% for\n k, v in hash %}\n          \n\\{% if\n k.is_a?(MacroId) %}\n            \n\\{% if\n type.union? %}\n              \n\\{% if\n type.union_types.includes?(String) %}\n                \n\\{% \nname = k.stringify %}\n              \n\\{% e\nlsif type.union_types.includes?(Symbol) %}\n                \n\\{% \nname = \":#{k}\".id %}\n              \n\\{% e\nlse %}\n                \n\\{% \nname = k %}\n              \n\\{% end\n %}\n            \n\\{% e\nlsif type == String %}\n              \n\\{% \nname = \"#{k}\" %}\n            \n\\{% e\nlsif  type == Symbol %}\n              \n\\{% \nname = \":#{k}\".id %}\n            \n\\{% e\nlse %}\n              \n\\{% \nname = k %}\n            \n\\{% end\n %}\n          \n\\{% e\nlse %}\n            \n\\{% \nname = k %}\n          \n\\{% end\n %}\n          \n%hash\n[\n\\{\n{name}}] = \n\\{\n{v}}.as(\n\\{\n{types.id}})\n        \n\\{% end\n %}\n        \n%hash\n\n      \nend\n    \nend\n\n    \n# accepts any hash or named tuple\n\n    \n# example: Ifrit.as_sym_hash(hash, String | Int32)\n\n    macro sym_hash_cast(hash, types)\n      Ifrit.typed_hash_cast(\n\\{\n{hash}}, Symbol, \n\\{\n{types}})\n    \nend\n\n    macro str_hash_cast(hash, types)\n      Ifrit.typed_hash_cast(\n\\{\n{hash}}, String, \n\\{\n{types}})\n    \nend\n\n    \n# accepts any hash\n\n    macro typed_hash_cast(hash, key, types)\n      begin\n        \n%buf\n = \n{} of \n\\{\n{key}} => \n\\{\n{types.id}}\n        \n\\{\n{hash.id}}.each \n{ |k, v| \n%buf\n[k.as(\n\\{\n{key}})] = v.as(\n\\{\n{types.id}}) }\n        \n%buf\n\n      \nend\n    \nend\n\n    \n# accepts hash literal\n\n    macro sym_hash(hash, types)\n      Ifrit.typed_hash(\n\\{\n{hash}}, Symbol, \n\\{\n{types}})\n    \nend\n\n    \n# accepts hash literal\n\n    macro str_hash(hash, types)\n      Ifrit.typed_hash(\n\\{\n{hash}}, String, \n\\{\n{types}})\n    \nend\n\n    \n# accepts any array\n\n    macro typed_array_cast(arr, klass)\n      begin\n        array = [] of \n\\{\n{klass}}\n        \n\\{\n{arr}}.each \n{ |e| array << \ne.as(\n\\{\n{klass}}) }\n        array\n      \nend\n    \nend\n\n    \n# accepts array literal\n\n    macro typed_array(arr, klass)\n      begin\n        [\n        \n\\{% for\n v in arr %}\n          \n\\{\n{v}}.as(\n\\{\n{klass}}),\n        \n\\{% end\n %}\n        ]\n      \nend\n    \nend\n\n    \n# accepts any hash\n\n    macro stringify_hash(hash, types)\n      begin\n        \n%hash\n = \n{} of String =>\n\\{\n{types}}\n        \n\\{\n{hash}}.each do |k, v|\n          \n%hash\n[k.to_s] = v.as(\n\\{\n{types}})\n        \nend\n        \n%hash\n\n      \nend\n    \nend\n  \n"}},{"id":"str_hash(hash,types)-macro","html_id":"str_hash(hash,types)-macro","name":"str_hash","doc":"accepts hash literal","summary":"<p>accepts hash literal</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"str_hash","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      Ifrit.typed_hash(\n{{ hash }}\n, String, \n{{ types }}\n)\n    \n"}},{"id":"str_hash_cast(hash,types)-macro","html_id":"str_hash_cast(hash,types)-macro","name":"str_hash_cast","doc":null,"summary":null,"abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"str_hash_cast","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      Ifrit.typed_hash_cast(\n{{ hash }}\n, String, \n{{ types }}\n)\n    \n"}},{"id":"stringify_hash(hash,types)-macro","html_id":"stringify_hash(hash,types)-macro","name":"stringify_hash","doc":"accepts any hash","summary":"<p>accepts any hash</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"stringify_hash","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        __temp_23 = \n{} of String =>\n{{ types }}\n\n        \n{{ hash }}\n.each do |k, v|\n          __temp_23[k.to_s] = v.as(\n{{ types }}\n)\n        \nend\n        __temp_23\n      \nend\n    \n"}},{"id":"sym_hash(hash,types)-macro","html_id":"sym_hash(hash,types)-macro","name":"sym_hash","doc":"accepts hash literal","summary":"<p>accepts hash literal</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"sym_hash","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      Ifrit.typed_hash(\n{{ hash }}\n, Symbol, \n{{ types }}\n)\n    \n"}},{"id":"sym_hash_cast(hash,types)-macro","html_id":"sym_hash_cast(hash,types)-macro","name":"sym_hash_cast","doc":"accepts any hash or named tuple\nexample: Ifrit.as_sym_hash(hash, String | Int32)","summary":"<p>accepts any hash or named tuple example: Ifrit.as_sym_hash(hash, String | Int32)</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"sym_hash_cast","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      Ifrit.typed_hash_cast(\n{{ hash }}\n, Symbol, \n{{ types }}\n)\n    \n"}},{"id":"typed_array(arr,klass)-macro","html_id":"typed_array(arr,klass)-macro","name":"typed_array","doc":"accepts array literal","summary":"<p>accepts array literal</p>","abstract":false,"args":[{"name":"arr","doc":null,"default_value":"","external_name":"arr","restriction":""},{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"args_string":"(arr, klass)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"typed_array","args":[{"name":"arr","doc":null,"default_value":"","external_name":"arr","restriction":""},{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        [\n        \n{% for v in arr %}\n          {{ v }}.as({{ klass }}),\n        {% end %}\n\n        ]\n      \nend\n    \n"}},{"id":"typed_array_cast(arr,klass)-macro","html_id":"typed_array_cast(arr,klass)-macro","name":"typed_array_cast","doc":"accepts any array","summary":"<p>accepts any array</p>","abstract":false,"args":[{"name":"arr","doc":null,"default_value":"","external_name":"arr","restriction":""},{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"args_string":"(arr, klass)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"typed_array_cast","args":[{"name":"arr","doc":null,"default_value":"","external_name":"arr","restriction":""},{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        array = [] of \n{{ klass }}\n\n        \n{{ arr }}\n.each \n{ |e| array << \ne.as(\n{{ klass }}\n) }\n        array\n      \nend\n    \n"}},{"id":"typed_hash(hash,key,types)-macro","html_id":"typed_hash(hash,key,types)-macro","name":"typed_hash","doc":"accepts only hash literals\nexample: Ifrit.typed_hash({\"a\" => 1, \"b\" => \"b\"}, String, Int32 | String)","summary":"<p>accepts only hash literals example: Ifrit.typed_hash({\"a\" => 1, \"b\" => \"b\"}, String, Int32 | String)</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, key, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"typed_hash","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        __temp_23 = \n{} of \n{{ key.id }}\n => \n{{ types.id }}\n\n        \n{% type = key.resolve %}\n\n        \n{% for k, v in hash %}\n          {% if k.is_a?(MacroId) %}\n            {% if type.union? %}\n              {% if type.union_types.includes?(String) %}\n                {% name = k.stringify %}\n              {% else %}{% if type.union_types.includes?(Symbol) %}\n                {% name = \":#{k}\".id %}\n              {% else %}\n                {% name = k %}\n              {% end %}{% end %}\n            {% else %}{% if type == String %}\n              {% name = \"#{k}\" %}\n            {% else %}{% if type == Symbol %}\n              {% name = \":#{k}\".id %}\n            {% else %}\n              {% name = k %}\n            {% end %}{% end %}{% end %}\n          {% else %}\n            {% name = k %}\n          {% end %}\n          __temp_23[{{ name }}] = {{ v }}.as({{ types.id }})\n        {% end %}\n\n        __temp_23\n      \nend\n    \n"}},{"id":"typed_hash_cast(hash,key,types)-macro","html_id":"typed_hash_cast(hash,key,types)-macro","name":"typed_hash_cast","doc":"accepts any hash","summary":"<p>accepts any hash</p>","abstract":false,"args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"args_string":"(hash, key, types)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/converter.cr#L124","def":{"name":"typed_hash_cast","args":[{"name":"hash","doc":null,"default_value":"","external_name":"hash","restriction":""},{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":""},{"name":"types","doc":null,"default_value":"","external_name":"types","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        __temp_24 = \n{} of \n{{ key }}\n => \n{{ types.id }}\n\n        \n{{ hash.id }}\n.each \n{ |k, v| __temp_24[k.as(\n{{ key }}\n)] = v.as(\n{{ types.id }}\n) }\n        __temp_24\n      \nend\n    \n"}}],"types":[{"html_id":"github.com/imdrasil/ifrit/Ifrit/Inflector","path":"Ifrit/Inflector.html","kind":"module","full_name":"Ifrit::Inflector","name":"Inflector","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"ifrit/inflector.cr","line_number":5,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inflector.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IRREGULAR_PLURAL_RULES","name":"IRREGULAR_PLURAL_RULES","value":"[[/person$/, \"people\"], [/man$/, \"men\"], [/child$/, \"children\"], [/sex$/, \"sexes\"], [/move$/, \"moves\"], [/zombie$/, \"zombies\"]]","doc":null,"summary":null},{"id":"IRREGULAR_SINGULAR_RULES","name":"IRREGULAR_SINGULAR_RULES","value":"[[/people$/, \"person\"], [/men$/, \"man\"], [/children$/, \"child\"], [/sexes$/, \"sex\"], [/moves$/, \"move\"], [/zombies$/, \"zombie\"]]","doc":null,"summary":null},{"id":"PLURAL_RULES","name":"PLURAL_RULES","value":"[[/(quiz)$/i, \"zes\", /$/i], [/^(oxen)$/i, \"oxen\", /^(oxen)$/i], [/^(ox)$/i, \"en\", /$/i], [/^(m|l)ice$/i, \"\", /$/i], [/^(m|l)ouse$/i, \"ice\", /ouse$/i], [/(matr|vert|ind)(ix|ex)$/i, \"ices\", /(ix|ex)$/i], [/(x|ch|ss|sh)$/i, \"es\", /$/i], [/([^aeiouy]|qu)y$/i, \"ies\", /y$/i], [/(hive)$/i, \"s\", /$/i], [/([^f]fe)$/i, \"ves\", /fe$/i], [/([lr]f)$/i, \"ves\", /f$/i], [/sis$/i, \"ses\", /sis$/i], [/[ti]a$/i, \"\", /$/i], [/([ti])um$/i, \"a\", /um$/i], [/(buffal|tomat)o$/i, \"es\", /$/i], [/(bu)s$/i, \"es\", /$/], [/(alias|status)$/i, \"es\", /$/], [/(octop|vir)i$/i, \"\", /$/], [/(octop|vir)us$/i, \"i\", /us$/i], [/^(ax|test)is$/i, \"es\", /is$/i], [/s$/i, \"s\", /s$/i], [/$/, \"s\", /$/]]","doc":null,"summary":null},{"id":"SINGULAR_RULES","name":"SINGULAR_RULES","value":"[[/(database)s$/i, \"\", /s$/i], [/(quiz)zes$/i, \"\", /zes$/i], [/(matr)ices$/i, \"ix\", /ices$/i], [/(vert|ind)ices$/i, \"ex\", /ices$/i], [/^(ox)en/i, \"\", /en$/i], [/(alias|status)(es)$/i, \"\", /es$/i], [/(octop|vir)(us|i)$/i, \"us\", /(us|i)$/i], [/^(a)x[ie]s$/i, \"xis\", /x[ie]s$/i], [/(cris|test)(is|es)$/i, \"is\", /(is|es)$/i], [/(shoe)s$/i, \"\", /s$/i], [/(o)es$/i, \"\", /es$/i], [/(bus)(es)$/i, \"\", /es$/i], [/^(m|l)ice$/i, \"ouse\", /ice$/i], [/(x|ch|ss|sh)es$/i, \"\", /es$/i], [/(m)ovies$/i, \"ovie\", /ovies$/i], [/(s)eries$/i, \"eries\", /eries$/i], [/([^aeiouy]|qu)ies$/i, \"y\", /ies$/i], [/([lr])ves$/i, \"f\", /ves$/i], [/(tive|hive)s$/i, \"\", /s$/i], [/([^f])ves$/i, \"fe\", /ves$/i], [/(^analy)(sis|ses)$/i, \"sis\", /(sis|ses)$/i], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i, \"sis\", /(sis|ses)$/i], [/([ti])a$/i, \"um\", /a$/i], [/(n)ews$/i, \"ews\", /ews$/i], [/(ss)$/i, \"\", /$/], [/s$/i, \"\", /s$/]]","doc":null,"summary":null},{"id":"UNCOUNTABLE","name":"UNCOUNTABLE","value":"[\"equipment\", \"information\", \"rice\", \"money\", \"species\", \"series\", \"fish\", \"sheep\", \"jeans\", \"police\"] of ::String","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/imdrasil/ifrit/Ifrit","kind":"module","full_name":"Ifrit","name":"Ifrit"},"doc":"Allows to pluralize values in compile-time.\n\nThis is a port of [inflector.cr](https://github.com/phoffer/inflector.cr).","summary":"<p>Allows to pluralize values in compile-time.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"pluralize(string)-macro","html_id":"pluralize(string)-macro","name":"pluralize","doc":"Pluralize given string literal.","summary":"<p>Pluralize given string literal.</p>","abstract":false,"args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"args_string":"(string)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inflector.cr#L80","def":{"name":"pluralize","args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      \n{% looking = true %}\n\n      \n{% if !(UNCOUNTABLE.includes?(string)) %}\n        {% for row in IRREGULAR_PLURAL_RULES %}\n          {% if looking && (string =~ row[0]) %}\n            {{ string.gsub(row[0], row[1]) }}\n            {% looking = false %}\n          {% end %}\n        {% end %}\n        {% if looking %}\n          {% for row in PLURAL_RULES %}\n            {% if looking == true %}\n              {% matcher = row[0]\nrepl = row[1]\nrule = row[2]\n %}\n              {% if string =~ matcher %}\n                {{ string.gsub(rule, repl) }}\n                {% looking = false %}\n              {% end %}\n            {% end %}\n          {% end %}\n        {% end %}\n      {% else %}\n        {{ string }}\n      {% end %}\n\n    \n"}},{"id":"singularize(string)-macro","html_id":"singularize(string)-macro","name":"singularize","doc":"Singularize given string literal.","summary":"<p>Singularize given string literal.</p>","abstract":false,"args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"args_string":"(string)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inflector.cr#L110","def":{"name":"singularize","args":[{"name":"string","doc":null,"default_value":"","external_name":"string","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      \n{% looking = true %}\n\n      \n{% if !(UNCOUNTABLE.includes?(string)) %}\n        {% for row in IRREGULAR_SINGULAR_RULES %}\n          {% if looking && (string =~ row[0]) %}\n            {{ string.gsub(row[0], row[1]) }}\n            {% looking = false %}\n          {% end %}\n        {% end %}\n        {% if looking %}\n          {% for row in SINGULAR_RULES %}\n            {% if looking == true %}\n              {% matcher = row[0]\nrepl = row[1]\nrule = row[2]\n %}\n              {% if string =~ matcher %}\n                {{ string.gsub(rule, repl) }}\n                {% looking = false %}\n              {% end %}\n            {% end %}\n          {% end %}\n        {% end %}\n      {% else %}\n        {{ string }}\n      {% end %}\n\n    \n"}}],"types":[]}]},{"html_id":"github.com/imdrasil/ifrit/InheritableJSON","path":"InheritableJSON.html","kind":"module","full_name":"InheritableJSON","name":"InheritableJSON","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"ifrit/inheritable_json.cr","line_number":5,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inheritable_json.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Allows to define class with JSON definition and allows inheritance.","summary":"<p>Allows to define class with JSON definition and allows inheritance.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"render_methods(klass)-macro","html_id":"render_methods(klass)-macro","name":"render_methods","doc":null,"summary":null,"abstract":false,"args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"args_string":"(klass)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/inheritable_json.cr#L57","def":{"name":"render_methods","args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"    \n{% definition = klass.constant(\"INHERITABLE_JSON_MAPPING\") %}\n\n    \n{% strict = false %}\n\n    def initialize(\n%pull\n : ::JSON::PullParser)\n      \n{% for key, value in definition %}\n        %var{key.id} = nil\n        %found{key.id} = false\n      {% end %}\n\n\n        \n%pull\n.read_object do |key|\n          case key\n          \n{% for key, value in definition %}\n            when {{ value[\"key\"] != nil ? value[\"key\"].id : key }}\n              {% type = value[\"type\"].id %}\n              %found{key.id} = true\n\n              %var{key.id} =\n                {% if (value[\"nilable\"] == \"true\") || (value[\"default\"] != nil) %} %pull.read_null_or { {% end %}\n\n                {% if value[\"root\"] %}\n                  %pull.on_key!({{ value[\"root\"].id }}) do\n                {% end %}\n\n                {% if value[\"converter\"] %}\n                  {{ value[\"converter\"].id }}.from_json(%pull)\n                {% else %}{% if value[\"use_constructor\"] == \"true\" %}\n                  {{ type }}.new(%pull)\n                {% else %}\n                  ::Union({{ type }}).new(%pull)\n                {% end %}{% end %}\n\n                {% if value[\"root\"] %}\n                  end\n                {% end %}\n\n                {% if (value[\"nilable\"] == \"true\") || (value[\"default\"] != nil) %} } {% end %}\n\n          {% end %}\n\n          \nelse\n            \n{% if strict %}\n              raise ::JSON::ParseException.new(\"Unknown json attribute: #{key}\", 0, 0)\n            {% else %}\n              %pull.skip\n            {% end %}\n\n          \nend\n        \nend\n\n        \n{% for key, value in definition %}\n          {% if !((value[\"nilable\"] == \"true\") || (value[\"default\"] != nil)) %}\n            if %var{key.id}.nil? && !%found{key.id} && !::Union({{ value[\"type\"].id }}).nilable?\n              raise ::JSON::ParseException.new(\"Missing json attribute: {{ (value[:key] || key).id }}\", 0, 0)\n            end\n          {% end %}\n        {% end %}\n\n\n        \n{% for key, value in definition %}\n          {% if value[\"nilable\"] == \"true\" %}\n            {% if value[\"default\"] != nil %}\n              @{{ key.id }} = %found{key.id} ? %var{key.id} : {{ value[\"default\"].id }}\n            {% else %}\n              @{{ key.id }} = %var{key.id}\n            {% end %}\n          {% else %}{% if value[\"default\"] != nil %}\n            @{{ key.id }} = %var{key.id}.nil? ? {{ value[\"default\"].id }} : %var{key.id}\n          {% else %}\n            @{{ key.id }} = (%var{key.id}).as({{ value[\"type\"].id }})\n          {% end %}{% end %}\n        {% end %}\n\n    \nend\n\n\n    def to_json(json : ::JSON::Builder)\n      json.object do\n        \n{% for key, value in definition %}\n          _{{ key.id }} = @{{ key.id }}\n\n          {% if !value[\"emit_null\"] %}\n            unless _{{ key.id }}.nil?\n          {% end %}\n\n            json.field({{ value[\"key\"] != nil ? value[\"key\"].id : key }}) do\n              {% if value[\"root\"] %}\n                {% if value[\"emit_null\"] %}\n                  if _{{ key.id }}.nil?\n                    nil.to_json(json)\n                  else\n                {% end %}\n\n                json.object do\n                  json.field({{ value[\"root\"].id }}) do\n              {% end %}\n\n              {% if value[\"converter\"] %}\n                if _{{ key.id }}\n                  {{ value[\"converter\"].id }}.to_json(_{{ key.id }}, json)\n                else\n                  nil.to_json(json)\n                end\n              {% else %}\n                _{{ key.id }}.to_json(json)\n              {% end %}\n\n              {% if value[\"root\"] %}\n                {% if value[\"emit_null\"] %}\n                  end\n                {% end %}\n                  end\n                end\n              {% end %}\n            end\n\n          {% if !value[\"emit_null\"] %}\n            end\n          {% end %}\n        {% end %}\n\n      \nend\n    \nend\n  \n"}}],"types":[]},{"html_id":"github.com/imdrasil/ifrit/NamedTuple","path":"NamedTuple.html","kind":"struct","full_name":"NamedTuple(**T)","name":"NamedTuple","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":109,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"A named tuple is a fixed-size, immutable, stack-allocated mapping\nof a fixed set of keys to values.\n\nYou can think of a `NamedTuple` as an immutable `Hash` whose keys (which\nare of type `Symbol`), and the types for each key, are known at compile time.\n\nA named tuple can be created with a named tuple literal:\n\n```\nlanguage = {name: \"Crystal\", year: 2011} # NamedTuple(name: String, year: Int32)\n\nlanguage[:name]  # => \"Crystal\"\nlanguage[:year]  # => 2011\nlanguage[:other] # compile time error\n```\n\nThe compiler knows what types are in each key, so when indexing a named tuple\nwith a symbol literal the compiler will return the value for that key and\nwith the expected type, like in the above snippet. Indexing with a symbol\nliteral for which there's no key will give a compile-time error.\n\nIndexing with a symbol that is only known at runtime will return\na value whose type is the union of all the types in the named tuple,\nand might raise `KeyError`.","summary":"<p>A named tuple is a fixed-size, immutable, stack-allocated mapping of a fixed set of keys to values.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L111","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L111","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"empty?"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Nil","path":"Nil.html","kind":"struct","full_name":"Nil","name":"Nil","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":67,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"The `Nil` type has only one possible value: `nil`.\n\n`nil` is commonly used to represent the absence of a value.\nFor example, `String#index` returns the position of the character or `nil` if it's not\nin the string:\n\n```\nstr = \"Hello world\"\nstr.index 'e' # => 1\nstr.index 'a' # => nil\n```\n\nIn the above example, trying to invoke a method on the returned value will\ngive a compile time error unless both `Int32` and `Nil` define that method:\n\n```\nstr = \"Hello world\"\nidx = str.index 'e'\nidx + 1 # Error: undefined method '+' for Nil\n```\n\nThe language and the standard library provide short, readable, easy ways to deal with `nil`,\nsuch as `Object#try` and `Object#not_nil!`:\n\n```\nstr = \"Hello world\"\n\n# The index of 'e' in str or 0 if not found\nidx1 = str.index('e') || 0\n\nidx2 = str.index('a')\nif idx2\n  # Compiles: idx2 can't be nil here\n  idx2 + 1\nend\n\n# Tell the compiler that we are sure the returned\n# value is not nil: raises a runtime exception\n# if our assumption doesn't hold.\nidx3 = str.index('o').not_nil!\n```","summary":"<p>The <code><a href=\"Nil.html\">Nil</a></code> type has only one possible value: <code>nil</code>.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L69","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L69","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"true"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Number","path":"Number.html","kind":"struct","full_name":"Number","name":"Number","abstract":true,"superclass":{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":129,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"The top-level number type.","summary":"<p>The top-level number type.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"to_bool-instance-method","html_id":"to_bool-instance-method","name":"to_bool","doc":"Converts to boolean based on value (`1` - `true`, `0` - `false`, `ArgumentError` otherwise).","summary":"<p>Converts to boolean based on value (<code>1</code> - <code>true</code>, <code>0</code> - <code>false</code>, <code>ArgumentError</code> otherwise).</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L131","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L131","def":{"name":"to_bool","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if self == 1\n  return true\nend\nif self == 0\n  return false\nend\nraise(ArgumentError.new(\"invalid value for Boolean: \\\"#{self}\\\"\"))\n"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Object","path":"Object.html","kind":"class","full_name":"Object","name":"Object","abstract":true,"superclass":null,"ancestors":[],"locations":[{"filename":"ifrit/core.cr","line_number":3,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"`Object` is the base type of all Crystal objects.","summary":"<p><code><a href=\"Object.html\">Object</a></code> is the base type of all Crystal objects.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?:Bool-instance-method","html_id":"blank?:Bool-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":" : Bool","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L25","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L25","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Bool","visibility":"Public","body":"false"}},{"id":"present?-instance-method","html_id":"present?-instance-method","name":"present?","doc":"Returns if object is not *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is not <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L30","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L30","def":{"name":"present?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"!blank?"}}],"macros":[{"id":"singleton_delegate(*methods,to)-macro","html_id":"singleton_delegate(*methods,to)-macro","name":"singleton_delegate","doc":"Defines class method delegation.\n\n```\nclass A\n  def self.method1\n  end\nend\n\nclass B\n  singleton_delegate :method1, to: A\nend\n```","summary":"<p>Defines class method delegation.</p>","abstract":false,"args":[{"name":"methods","doc":null,"default_value":"","external_name":"methods","restriction":""},{"name":"to","doc":null,"default_value":"","external_name":"to","restriction":""}],"args_string":"(*methods, to)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L16","def":{"name":"singleton_delegate","args":[{"name":"methods","doc":null,"default_value":"","external_name":"methods","restriction":""},{"name":"to","doc":null,"default_value":"","external_name":"to","restriction":""}],"double_splat":null,"splat_index":0,"block_arg":null,"visibility":"Public","body":"    \n{% for m in method %}\n      def self.{{ m.id }}(*args, **opts)\n        {{ to[:to].id }}.{{ m.id }}(*args, **opts)\n      end\n    {% end %}\n\n  \n"}}],"types":[]},{"html_id":"github.com/imdrasil/ifrit/String","path":"String.html","kind":"class","full_name":"String","name":"String","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":120,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"},{"filename":"ifrit/symbol_table.cr","line_number":40,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"A `String` represents an immutable sequence of UTF-8 characters.\n\nA `String` is typically created with a string literal, enclosing UTF-8 characters\nin double quotes:\n\n```\n\"hello world\"\n```\n\nA backslash can be used to denote some characters inside the string:\n\n```\n\"\\\"\" # double quote\n\"\\\\\" # backslash\n\"\\e\" # escape\n\"\\f\" # form feed\n\"\\n\" # newline\n\"\\r\" # carriage return\n\"\\t\" # tab\n\"\\v\" # vertical tab\n```\n\nYou can use a backslash followed by an *u* and four hexadecimal characters to denote a unicode codepoint written:\n\n```\n\"\\u0041\" # == \"A\"\n```\n\nOr you can use curly braces and specify up to six hexadecimal numbers (0 to 10FFFF):\n\n```\n\"\\u{41}\" # == \"A\"\n```\n\nA string can span multiple lines:\n\n```\n\"hello\n      world\" # same as \"hello\\n      world\"\n```\n\nNote that in the above example trailing and leading spaces, as well as newlines,\nend up in the resulting string. To avoid this, you can split a string into multiple lines\nby joining multiple literals with a backslash:\n\n```\n\"hello \" \\\n\"world, \" \\\n\"no newlines\" # same as \"hello world, no newlines\"\n```\n\nAlternatively, a backslash followed by a newline can be inserted inside the string literal:\n\n```\n\"hello \\\n     world, \\\n     no newlines\" # same as \"hello world, no newlines\"\n```\n\nIn this case, leading whitespace is not included in the resulting string.\n\nIf you need to write a string that has many double quotes, parentheses, or similar\ncharacters, you can use alternative literals:\n\n```\n# Supports double quotes and nested parentheses\n%(hello (\"world\")) # same as \"hello (\\\"world\\\")\"\n\n# Supports double quotes and nested brackets\n%[hello [\"world\"]] # same as \"hello [\\\"world\\\"]\"\n\n# Supports double quotes and nested curlies\n%{hello {\"world\"}} # same as \"hello {\\\"world\\\"}\"\n\n# Supports double quotes and nested angles\n%<hello <\"world\">> # same as \"hello <\\\"world\\\">\"\n```\n\nTo create a `String` with embedded expressions, you can use string interpolation:\n\n```\na = 1\nb = 2\n\"sum = #{a + b}\" # \"sum = 3\"\n```\n\nThis ends up invoking `Object#to_s(IO)` on each expression enclosed by `#{...}`.\n\nIf you need to dynamically build a string, use `String#build` or `IO::Memory`.\n\n### Non UTF-8 valid strings\n\nString might end up being conformed of bytes which are an invalid\nbyte sequence according to UTF-8. This can happen if the string is created\nvia one of the constructors that accept bytes, or when getting a string\nfrom `String.build` or `IO::Memory`. No exception will be raised, but\ninvalid byte sequences, when asked as chars, will use the unicode replacement\nchar (value 0xFFFD). For example:\n\n```\n# here 255 is not a valid byte value in the UTF-8 encoding\nstring = String.new(Bytes[255, 97])\nstring.valid_encoding? # => false\n\n# The first char here is the unicode replacement char\nstring.chars # => ['�', 'a']\n```\n\nOne can also create strings with specific byte value in them by\nusing octal and hexadecimal escape sequences:\n\n```\n# Octal escape sequences\n\"\\101\" # # => \"A\"\n\"\\12\"  # # => \"\\n\"\n\"\\1\"   # string with one character with code point 1\n\"\\377\" # string with one byte with value 255\n\n# Hexadecimal escape sequences\n\"\\x41\" # # => \"A\"\n\"\\xFF\" # string with one byte with value 255\n```\n\nThe reason for allowing strings that don't have a valid UTF-8 sequence\nis that the world is full of content that isn't properly encoded,\nand having a program raise an exception or stop because of this\nis not good. It's better if programs are more resilient, but\nshow a replacement character when there's an error in incoming data.","summary":"<p>A <code><a href=\"String.html\">String</a></code> represents an immutable sequence of UTF-8 characters.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"to_bool-instance-method","html_id":"to_bool-instance-method","name":"to_bool","doc":"Converts to boolean based on text. If string has invalid format - `ArgumentError` will be raised.","summary":"<p>Converts to boolean based on text.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L122","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L122","def":{"name":"to_bool","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (self == true) || (self =~ (/^(true|t|yes|y|1)$/i))\n  return true\nend\nif ((self == false) || self.blank?) || (self =~ (/^(false|f|no|n|0)$/i))\n  return false\nend\nraise(ArgumentError.new(\"invalid value for Boolean: \\\"#{self}\\\"\"))\n"}},{"id":"to_sym-instance-method","html_id":"to_sym-instance-method","name":"to_sym","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr#L41","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr#L41","def":{"name":"to_sym","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"SymbolTable.by_string(self)"}}],"macros":[],"types":[]},{"html_id":"github.com/imdrasil/ifrit/Struct","path":"Struct.html","kind":"struct","full_name":"Struct","name":"Struct","abstract":true,"superclass":{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":47,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"github.com/imdrasil/ifrit/BitArray","kind":"struct","full_name":"BitArray","name":"BitArray"}],"including_types":[],"namespace":null,"doc":"Defines class method delegation.\n\n```\nstruct A\n  def self.method1\n  end\nend\n\nstruct B\n  singleton_delegate :method1, to: A\nend\n```","summary":"<p>Defines class method delegation.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L57","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L57","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"false"}},{"id":"present?-instance-method","html_id":"present?-instance-method","name":"present?","doc":"Returns if object is not *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is not <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L62","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L62","def":{"name":"present?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"!blank?"}}],"macros":[{"id":"singleton_delegate(*methods,to)-macro","html_id":"singleton_delegate(*methods,to)-macro","name":"singleton_delegate","doc":null,"summary":null,"abstract":false,"args":[{"name":"methods","doc":null,"default_value":"","external_name":"methods","restriction":""},{"name":"to","doc":null,"default_value":"","external_name":"to","restriction":""}],"args_string":"(*methods, to)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L48","def":{"name":"singleton_delegate","args":[{"name":"methods","doc":null,"default_value":"","external_name":"methods","restriction":""},{"name":"to","doc":null,"default_value":"","external_name":"to","restriction":""}],"double_splat":null,"splat_index":0,"block_arg":null,"visibility":"Public","body":"    \n{% for m in method %}\n      def self.{{ m.id }}\n        {{ to[:to].id }}.{{ m.id }}\n      end\n    {% end %}\n\n  \n"}}],"types":[]},{"html_id":"github.com/imdrasil/ifrit/SymbolTable","path":"SymbolTable.html","kind":"class","full_name":"SymbolTable","name":"SymbolTable","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/SymbolTable/Methods","kind":"module","full_name":"SymbolTable::Methods","name":"Methods"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/symbol_table.cr","line_number":12,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"STR_HASH","name":"STR_HASH","value":"{} of String => Symbol","doc":null,"summary":null},{"id":"SYM_HASH","name":"SYM_HASH","value":"{} of Symbol => String","doc":null,"summary":null}],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/SymbolTable/Methods","kind":"module","full_name":"SymbolTable::Methods","name":"Methods"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Allows to register symbols and then convert strings to them.\n\n```\ninclude Ifrit::SymbolTable\n\na = s(:asd)\n# ...\n\"asd\".to_sym # :asd\n```","summary":"<p>Allows to register symbols and then convert strings to them.</p>","class_methods":[{"id":"by_string(str)-class-method","html_id":"by_string(str)-class-method","name":"by_string","doc":null,"summary":null,"abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr#L33","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr#L33","def":{"name":"by_string","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  STR_HASH[str]\nrescue KeyError\n  raise(UnknownSymbol.new(str))\nend"}}],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/imdrasil/ifrit/SymbolTable/Methods","path":"SymbolTable/Methods.html","kind":"module","full_name":"SymbolTable::Methods","name":"Methods","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"ifrit/symbol_table.cr","line_number":16,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"github.com/imdrasil/ifrit/SymbolTable","kind":"class","full_name":"SymbolTable","name":"SymbolTable"}],"namespace":{"html_id":"github.com/imdrasil/ifrit/SymbolTable","kind":"class","full_name":"SymbolTable","name":"SymbolTable"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[{"id":"s(symbol)-macro","html_id":"s(symbol)-macro","name":"s","doc":null,"summary":null,"abstract":false,"args":[{"name":"symbol","doc":null,"default_value":"","external_name":"symbol","restriction":""}],"args_string":"(symbol)","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr#L17","def":{"name":"s","args":[{"name":"symbol","doc":null,"default_value":"","external_name":"symbol","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      begin\n        \n{% if SymbolTable::SYM_HASH[symbol] == nil %}\n          {% SymbolTable::SYM_HASH[symbol] = symbol.id.stringify %}\n          {% SymbolTable::STR_HASH[SymbolTable::SYM_HASH[symbol]] = symbol %}\n        {% end %}\n\n        \n{{ symbol }}\n\n      \nend\n    \n"}}],"types":[]},{"html_id":"github.com/imdrasil/ifrit/SymbolTable/UnknownSymbol","path":"SymbolTable/UnknownSymbol.html","kind":"class","full_name":"SymbolTable::UnknownSymbol","name":"UnknownSymbol","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/imdrasil/ifrit/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/symbol_table.cr","line_number":13,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/symbol_table.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/imdrasil/ifrit/SymbolTable","kind":"class","full_name":"SymbolTable","name":"SymbolTable"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"github.com/imdrasil/ifrit/Tuple","path":"Tuple.html","kind":"struct","full_name":"Tuple(*T)","name":"Tuple","abstract":false,"superclass":{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},"ancestors":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/imdrasil/ifrit/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/imdrasil/ifrit/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/imdrasil/ifrit/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/imdrasil/ifrit/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"ifrit/core.cr","line_number":102,"url":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr"}],"repository_name":"github.com/imdrasil/ifrit","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/imdrasil/ifrit/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/imdrasil/ifrit/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"A tuple is a fixed-size, immutable, stack-allocated sequence of values\nof possibly different types.\n\nYou can think of a `Tuple` as an immutable `Array` whose types for each position\nare known at compile time.\n\nA tuple can be created with the usual `new` method or with a tuple literal:\n\n```\ntuple = {1, \"hello\", 'x'} # Tuple(Int32, String, Char)\ntuple[0]                  # => 1\ntuple[1]                  # => \"hello\"\ntuple[2]                  # => 'x'\n```\n\nThe compiler knows what types are in each position, so when indexing\na tuple with an integer literal the compiler will return\nthe value in that index and with the expected type, like in the above\nsnippet. Indexing with an integer literal outside the bounds of the tuple\nwill give a compile-time error.\n\nIndexing with an integer value that is only known at runtime will return\na value whose type is the union of all the types in the tuple, and might raise\n`IndexError`.\n\nTuples are the preferred way to return fixed-size multiple return\nvalues because no memory is needed to be allocated for them:\n\n```\ndef one_and_hello\n  {1, \"hello\"}\nend\n\none, hello = one_and_hello\none   # => 1\nhello # => \"hello\"\n```\n\nGood examples of the above are `Number#divmod` and `Enumerable#minmax`.\n\nTuples can be splat with the `*` operator and passed to methods:\n\n```\ndef multiply(string, value)\n  string * value\nend\n\ntuple = {\"hey\", 2}\nvalue = multiply(*tuple) # same as multiply tuple[0], tuple[1]\nvalue                    # => \"heyhey\"\n```\n\nFinally, when using a splat argument in a method definition its type\nwill be a tuple of the call arguments:\n\n```\ndef splat_test(*args)\n  args\nend\n\ntuple = splat_test 1, \"hello\", 'x'\ntuple.class # => Tuple(Int32, String, Char)\ntuple       # => {1, \"hello\", 'x'}\n```","summary":"<p>A tuple is a fixed-size, immutable, stack-allocated sequence of values of possibly different types.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"blank?-instance-method","html_id":"blank?-instance-method","name":"blank?","doc":"Returns if object is *blank* one - empty (or whitespaced) string, empty array, empty hash, `nil` or `false`.","summary":"<p>Returns if object is <em>blank</em> one - empty (or whitespaced) string, empty array, empty hash, <code>nil</code> or <code>false</code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L104","source_link":"https://github.com/imdrasil/ifrit/blob/3d062527c231b233714bf70c2563988429ff4c9a/src/ifrit/core.cr#L104","def":{"name":"blank?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"empty?"}}],"macros":[],"types":[]}]}})