<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 0.27.0">


<link href="css/style.css" rel="stylesheet" type="text/css">

<script type="text/javascript" src="js/doc.js"></script>
<script type="text/javascript">
  CrystalDoc.base_path = "";
</script>

  <meta id="repository-name" content="github.com/imdrasil/view_model.cr">
  <title>README - github.com/imdrasil/view_model.cr</title>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="repository-links">
      <a href="index.html">README</a>
    </div>
  </div>

  <div class="search-results" class="hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="github.com/imdrasil/view_model.cr/ViewModel" data-name="viewmodel">
      <a href="ViewModel.html">ViewModel</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/view_model.cr/ViewModel/Base" data-name="viewmodel::base">
      <a href="ViewModel/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/view_model.cr/ViewModel/Config" data-name="viewmodel::config">
      <a href="ViewModel/Config.html">Config</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/view_model.cr/ViewModel/FormBuilder" data-name="viewmodel::formbuilder">
      <a href="ViewModel/FormBuilder.html">FormBuilder</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/view_model.cr/ViewModel/FormTags" data-name="viewmodel::formtags">
      <a href="ViewModel/FormTags.html">FormTags</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/view_model.cr/ViewModel/FormTags/SHash" data-name="viewmodel::formtags::shash">
      <a href="ViewModel/FormTags/SHash.html">SHash</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/view_model.cr/ViewModel/Helpers" data-name="viewmodel::helpers">
      <a href="ViewModel/Helpers.html">Helpers</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1>ViewModel <a href="https://travis-ci.org/imdrasil/view_model.cr" target="_blank"><img src="https://travis-ci.org/imdrasil/view_model.cr.svg" alt="Build Status"/></a></h1>

<p>ViewModel pattern implementation with simple and effective form builder and view helpers.</p>

<h2>Installation</h2>

<p>Add this to your application's <code>shard.yml</code>:</p>

<pre><code class="language-yaml">dependencies:
  view_object:
    github: imdrasil/view_model.cr</code></pre>

<p>It uses <code>kilt</code> for template rendering so you also need to add template engine you want to use and require it as well.</p>

<h2>Usage</h2>

<h3>ViewModel</h3>

<p>Putting page rendering into action class ends with having fat helpers (like in rails) or putting a lot of view logic inside of templates. Also lack of native reusability in kilt makes you to define local variables with right name to be able to reuse them in a partials. Therefor much more suitable alternative is to have a separate class which encapsulates specific logic for a corresponding view. For such purpose this shard is created.</p>

<p>To do that load ViewModel</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;view_model&quot;</span>
<span class="k">require</span> <span class="s">&quot;kilt/slang&quot;</span> <span class="c"># or any other template engine supported by kilt</span></code></pre>

<p>Create a base view class:</p>

<pre><code class="language-crystal"><span class="k">class</span> <span class="t">ApplicationView</span> <span class="o">&lt;</span> <span class="t">ViewModel</span><span class="t">::</span><span class="t">Base</span>
<span class="k">end</span></code></pre>

<p>By default layout path is <code>"src/views/layouts/layout.slang"</code> but this can be easily redefined by <code>.layout</code> macro:</p>

<pre><code class="language-crystal"><span class="k">class</span> <span class="t">ApplicationView</span> <span class="o">&lt;</span> <span class="t">ViewModel</span><span class="t">::</span><span class="t">Base</span>
  layout <span class="s">&quot;app/views/layouts/layout&quot;</span>
<span class="k">end</span></code></pre>

<blockquote>Pay special attention - layout path doesn't include file extension.</blockquote>

<p>If you'd like to render your view without a layout - pass <code>false</code> as an argument.</p>

<p>Next define specified layout:</p>

<pre><code class="language-slang">html
  head
    title Page title
  body
    - yield_content</code></pre>

<p><code>yield_content</code> macro is just a alias for <code>yield(__kilt_io__)</code> - it yields <code>IO</code> to view <code>#content</code> method which renders content.</p>

<p>Now we can specify a view class.</p>

<pre><code class="language-crystal"><span class="c"># src/views/posts/show_view.cr</span>
<span class="k">module</span> <span class="t">Posts</span>
  <span class="k">class</span> <span class="t">ShowView</span> <span class="o">&lt;</span> <span class="t">ViewModel</span><span class="t">::</span><span class="t">Base</span>
    model post : <span class="t">Post</span>

    delegate <span class="n">:title</span>, <span class="n">:content</span>, to: post
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p><code>.model</code> macro creates getter for given attributes and generates constructor accepting them.</p>

<p>Content for a post object:</p>

<pre><code class="language-slang">.header
  h3 = title
.content
  = content</code></pre>

<p>By a convention this template file should be located in <code><view_class_folder>/<view_class_name_without_view/content.slang></code>, in our case it will be <code>src/views/posts/show/content.slang</code>.</p>

<p>For a view rendering <code>.view</code> macro can be used - just pass view name and required arguments:</p>

<pre><code class="language-crystal">view(<span class="s">&quot;posts/show&quot;</span>, post)
<span class="c"># or for a collection</span>
collection_view(<span class="s">&quot;posts/show&quot;</span>, posts)</code></pre>

<h3>Partials</h3>

<p>If you would like to define some shared templates or separate your view into several partials use <code>.def_partial</code> macro:</p>

<pre><code class="language-crystal"><span class="k">module</span> <span class="t">SharedPartials</span>
  <span class="k">include</span> <span class="t">ViewModel</span><span class="t">::</span><span class="t">Helpers</span>

  def_partial button, color
<span class="k">end</span>

<span class="k">module</span> <span class="t">Posts</span>
  <span class="k">class</span> <span class="t">ShowView</span> <span class="o">&lt;</span> <span class="t">ApplicationView</span>
    <span class="k">include</span> <span class="t">SharedPartials</span>

    def_partial body
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>If you need to define a module with partials - include <code><a href="ViewModel/Helpers.html">ViewModel::Helpers</a></code> module into it. <code>.def_partial</code> accepts partial name as a first argument and partial arguments as all others. All partial template paths are calculated same was as for content files of view objects. The only difference is that partial files name has a <code>_</code> symbol prefix: <code>src/views/shared_partials/_button.slang</code>.</p>

<p>To render a partial use <code>.render_partial</code> macro:</p>

<pre><code class="language-slang">.buttons
  - render_partial :button, :read</code></pre>

<h3>Html helpers</h3>

<p>Also this shard provides HTML helper methods. All methods are automatically included in <code><a href="ViewModel/Base.html">ViewModel::Base</a></code>.</p>

<p>Methods description:</p>

<ul><li><code>content_tag</code> - builds given tag with given options; could accept block for nested content</li><li><code>link_to</code> - builds link</li><li><code>label_tag</code> - builds <code>label</code></li><li><code>select_tag</code> - builds <code>select</code> tag; automatically generates <code>option</code> tags for given array</li><li><code>text_area_tag</code></li><li><code>hidden_tag</code></li><li><code>text_tag</code></li><li><code>submit_tag</code></li><li><code>file_tag</code></li><li><code>password_tag</code></li><li><code>email_tag</code></li><li><code>checkbox_tag</code></li><li><code>radio_tag</code></li><li><code>time_tag</code></li><li><code>date_tag</code></li><li><code>number_tag</code></li></ul>

<h4>FormBuilder</h4>

<p>To build form with automatically generated names and ids of inputs :</p>

<pre><code class="language-slang">- build_form(:some_form, "/posts", :post) do |f|
    p here could be some other html
    div
      - f.text_field :name
    - f.select_field :tag, [[1, "crystal"], [2, "ruby"]], 1
    - f.submit "Save"</code></pre>

<p><code>.build_form</code> macro creates <code><a href="ViewModel/FormBuilder.html">ViewModel::FormBuilder</a></code> and passes it to the block. Form builder provides a set of methods similar to ones described above. All inputs will get own id and class based on it's name.</p>

<p>All form builder methods manipulate <code>__kilt_io__</code> directly and returns <code>nil</code> so it isn't important the way to call them: with <code>-</code>, <code>=</code> or <code>==</code>.</p>

<p>If you specify a form method different from <code>get</code> and <code>post</code> - form builder will add additional hidden input with name <code>_method</code> for the given method and set current form method to <code>post</code>.</p>

<h3>link_to</h3>

<p>Also HTML helper includes <code>.link_to</code> macro. It allows to generate <code><a></code> tag with all needed data.</p>

<pre><code class="language-slang">== link_to "Show", "/posts/23", { "class" => "special-link" }

== link_to "/order/12" do
  span
    b Open</code></pre>

<p>If you want to make a link to do a non-GET request (e.g. delete button), you can specify <code>method</code> argument and additionally load <code>libs/view_model/assets/view_model.js</code> file.</p>

<pre><code class="language-slang">== link_to "delete", "/comments/56", :delete</code></pre>

<h2>Development</h2>

<p>There are still a lot of work to do. Tasks for next versions:</p>

<ul><li>[ ] add spec matchers</li><li>[ ] add more html helpers</li><li>[ ] add array support in name generation</li></ul>

<h2>Contributing</h2>

<ol><li><a href=" https://github.com/imdrasil/view_model.cr/fork " target="_blank">Fork it</a></li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<p>Please ask me before starting work on smth.</p>

<p>Also if you want to use it in your application (for now shard is almost ready for use in production) - ping me please, my email you can find in my profile.</p>

<p>To run test use regular <code>crystal spec</code>.</p>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/imdrasil" target="_blank">imdrasil</a> Roman Kalnytskyi - creator, maintainer</li></ul>
</div>
</body>
</html>
