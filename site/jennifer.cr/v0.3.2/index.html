<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta id="repository-name" content="github.com/imdrasil/jennifer.cr">
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="js/doc.js"></script>
  <title>README - github.com/imdrasil/jennifer.cr</title>
</head>
<body>

<div id="types-list">
  <div id="search-box">
    <input type="search" id="search-input" placeholder="Search...">
  </div>

  <ul>
    <li class="current"><a href="index.html">README</a></li>
  </ul>

  <ul>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer" data-name="jennifer">
      <a href="Jennifer.html">Jennifer</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter" data-name="jennifer::adapter">
      <a href="Jennifer/Adapter.html">Adapter</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter/Base" data-name="jennifer::adapter::base">
      <a href="Jennifer/Adapter/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter/EnumType" data-name="jennifer::adapter::enumtype">
      <a href="Jennifer/Adapter/EnumType.html">EnumType</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter/Postgres" data-name="jennifer::adapter::postgres">
      <a href="Jennifer/Adapter/Postgres.html">Postgres</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter/Postgres/ExecResult" data-name="jennifer::adapter::postgres::execresult">
      <a href="Jennifer/Adapter/Postgres/ExecResult.html">ExecResult</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Adapter/RequestMethods" data-name="jennifer::adapter::requestmethods">
      <a href="Jennifer/Adapter/RequestMethods.html">RequestMethods</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/AnyArgument" data-name="jennifer::anyargument">
      <a href="Jennifer/AnyArgument.html">AnyArgument</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/AnyResult" data-name="jennifer::anyresult">
      <a href="Jennifer/AnyResult.html">AnyResult</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/BadQuery" data-name="jennifer::badquery">
      <a href="Jennifer/BadQuery.html">BadQuery</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/BaseException" data-name="jennifer::baseexception">
      <a href="Jennifer/BaseException.html">BaseException</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Config" data-name="jennifer::config">
      <a href="Jennifer/Config.html">Config</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/DBAny" data-name="jennifer::dbany">
      <a href="Jennifer/DBAny.html">DBAny</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration" data-name="jennifer::migration">
      <a href="Jennifer/Migration.html">Migration</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/Base" data-name="jennifer::migration::base">
      <a href="Jennifer/Migration/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/Runner" data-name="jennifer::migration::runner">
      <a href="Jennifer/Migration/Runner.html">Runner</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder" data-name="jennifer::migration::tablebuilder">
      <a href="Jennifer/Migration/TableBuilder.html">TableBuilder</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base" data-name="jennifer::migration::tablebuilder::base">
      <a href="Jennifer/Migration/TableBuilder/Base.html">Base</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base/AAllowedTypes" data-name="jennifer::migration::tablebuilder::base::aallowedtypes">
      <a href="Jennifer/Migration/TableBuilder/Base/AAllowedTypes.html">AAllowedTypes</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base/AllowedTypes" data-name="jennifer::migration::tablebuilder::base::allowedtypes">
      <a href="Jennifer/Migration/TableBuilder/Base/AllowedTypes.html">AllowedTypes</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base/DB_OPTIONS" data-name="jennifer::migration::tablebuilder::base::db_options">
      <a href="Jennifer/Migration/TableBuilder/Base/DB_OPTIONS.html">DB_OPTIONS</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base/EAllowedTypes" data-name="jennifer::migration::tablebuilder::base::eallowedtypes">
      <a href="Jennifer/Migration/TableBuilder/Base/EAllowedTypes.html">EAllowedTypes</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Base/HAllowedTypes" data-name="jennifer::migration::tablebuilder::base::hallowedtypes">
      <a href="Jennifer/Migration/TableBuilder/Base/HAllowedTypes.html">HAllowedTypes</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/ChangeEnum" data-name="jennifer::migration::tablebuilder::changeenum">
      <a href="Jennifer/Migration/TableBuilder/ChangeEnum.html">ChangeEnum</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/ChangeTable" data-name="jennifer::migration::tablebuilder::changetable">
      <a href="Jennifer/Migration/TableBuilder/ChangeTable.html">ChangeTable</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/CreateEnum" data-name="jennifer::migration::tablebuilder::createenum">
      <a href="Jennifer/Migration/TableBuilder/CreateEnum.html">CreateEnum</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/CreateTable" data-name="jennifer::migration::tablebuilder::createtable">
      <a href="Jennifer/Migration/TableBuilder/CreateTable.html">CreateTable</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/DropEnum" data-name="jennifer::migration::tablebuilder::dropenum">
      <a href="Jennifer/Migration/TableBuilder/DropEnum.html">DropEnum</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/DropTable" data-name="jennifer::migration::tablebuilder::droptable">
      <a href="Jennifer/Migration/TableBuilder/DropTable.html">DropTable</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/TableBuilder/Raw" data-name="jennifer::migration::tablebuilder::raw">
      <a href="Jennifer/Migration/TableBuilder/Raw.html">Raw</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Migration/Version" data-name="jennifer::migration::version">
      <a href="Jennifer/Migration/Version.html">Version</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model" data-name="jennifer::model">
      <a href="Jennifer/Model.html">Model</a>
      
        <ul>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/Base" data-name="jennifer::model::base">
      <a href="Jennifer/Model/Base.html">Base</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/Base/Supportable" data-name="jennifer::model::base::supportable">
      <a href="Jennifer/Model/Base/Supportable.html">Supportable</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/Callback" data-name="jennifer::model::callback">
      <a href="Jennifer/Model/Callback.html">Callback</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/IRelationContainer" data-name="jennifer::model::irelationcontainer">
      <a href="Jennifer/Model/IRelationContainer.html">IRelationContainer</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/Mapping" data-name="jennifer::model::mapping">
      <a href="Jennifer/Model/Mapping.html">Mapping</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/RelationContainer" data-name="jennifer::model::relationcontainer(t, q)">
      <a href="Jennifer/Model/RelationContainer.html">RelationContainer</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/RelationDefinition" data-name="jennifer::model::relationdefinition">
      <a href="Jennifer/Model/RelationDefinition.html">RelationDefinition</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Model/Validation" data-name="jennifer::model::validation">
      <a href="Jennifer/Model/Validation.html">Validation</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Query" data-name="jennifer::query">
      <a href="Jennifer/Query.html">Query</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder" data-name="jennifer::querybuilder">
      <a href="Jennifer/QueryBuilder.html">QueryBuilder</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/And" data-name="jennifer::querybuilder::and">
      <a href="Jennifer/QueryBuilder/And.html">And</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Condition" data-name="jennifer::querybuilder::condition">
      <a href="Jennifer/QueryBuilder/Condition.html">Condition</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Criteria" data-name="jennifer::querybuilder::criteria">
      <a href="Jennifer/QueryBuilder/Criteria.html">Criteria</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Criteria/Rightable" data-name="jennifer::querybuilder::criteria::rightable">
      <a href="Jennifer/QueryBuilder/Criteria/Rightable.html">Rightable</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/ExpressionBuilder" data-name="jennifer::querybuilder::expressionbuilder">
      <a href="Jennifer/QueryBuilder/ExpressionBuilder.html">ExpressionBuilder</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Join" data-name="jennifer::querybuilder::join">
      <a href="Jennifer/QueryBuilder/Join.html">Join</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/LogicOperator" data-name="jennifer::querybuilder::logicoperator">
      <a href="Jennifer/QueryBuilder/LogicOperator.html">LogicOperator</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/ModelQuery" data-name="jennifer::querybuilder::modelquery(t)">
      <a href="Jennifer/QueryBuilder/ModelQuery.html">ModelQuery</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Or" data-name="jennifer::querybuilder::or">
      <a href="Jennifer/QueryBuilder/Or.html">Or</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Query" data-name="jennifer::querybuilder::query">
      <a href="Jennifer/QueryBuilder/Query.html">Query</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/RawSql" data-name="jennifer::querybuilder::rawsql">
      <a href="Jennifer/QueryBuilder/RawSql.html">RawSql</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/QueryBuilder/Xor" data-name="jennifer::querybuilder::xor">
      <a href="Jennifer/QueryBuilder/Xor.html">Xor</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/RecordNotFound" data-name="jennifer::recordnotfound">
      <a href="Jennifer/RecordNotFound.html">RecordNotFound</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation" data-name="jennifer::relation">
      <a href="Jennifer/Relation.html">Relation</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/Base" data-name="jennifer::relation::base(t, q)">
      <a href="Jennifer/Relation/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/BelongsTo" data-name="jennifer::relation::belongsto(t, q)">
      <a href="Jennifer/Relation/BelongsTo.html">BelongsTo</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/HasMany" data-name="jennifer::relation::hasmany(t, q)">
      <a href="Jennifer/Relation/HasMany.html">HasMany</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/HasOne" data-name="jennifer::relation::hasone(t, q)">
      <a href="Jennifer/Relation/HasOne.html">HasOne</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/IRelation" data-name="jennifer::relation::irelation">
      <a href="Jennifer/Relation/IRelation.html">IRelation</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Relation/ManyToMany" data-name="jennifer::relation::manytomany(t, q)">
      <a href="Jennifer/Relation/ManyToMany.html">ManyToMany</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/StubRelation" data-name="jennifer::stubrelation">
      <a href="Jennifer/StubRelation.html">StubRelation</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/Support" data-name="jennifer::support">
      <a href="Jennifer/Support.html">Support</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Jennifer/UnknownRelation" data-name="jennifer::unknownrelation">
      <a href="Jennifer/UnknownRelation.html">UnknownRelation</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/jennifer.cr/PG" data-name="pg">
      <a href="PG.html">PG</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/PG/Numeric" data-name="pg::numeric">
      <a href="PG/Numeric.html">Numeric</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/PG/ResultSet" data-name="pg::resultset">
      <a href="PG/ResultSet.html">ResultSet</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/jennifer.cr/Time" data-name="time">
      <a href="Time.html">Time</a>
      
    </li>
  
</ul>

</div>

<div id="main-content">
<h1>Jennifer <a href="https://travis-ci.org/imdrasil/jennifer.cr" target="_blank"><img src="https://travis-ci.org/imdrasil/jennifer.cr.svg" alt="Build Status"/></a></h1>

<p>Another one ActiveRecord pattern realization for Crystal with grate query DSL and migration mechanism.</p>

<h2>Installation</h2>

<p>Add this to your application's <code>shard.yml</code>:</p>

<pre><code class='language-yaml'>dependencies:
  jennifer:
    github: imdrasil/jennifer.cr</code></pre>

<p><strong>Also</strong> you need to choose one of existing adapters for your db: <a href="https://github.com/crystal-lang/crystal-mysql" target="_blank">mysql</a> or <a href="https://github.com/will/crystal-pg" target="_blank">postgres</a>.</p>

<h2>Usage</h2>

<h3>Configuration</h3>

<p>Put</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;jennifer/adapter/mysql&quot;</span> <span class="c"># for mysql</span>
<span class="k">require</span> <span class="s">&quot;jennifer/adapter/postgres&quot;</span> <span class="c"># for postgres</span>
<span class="k">require</span> <span class="s">&quot;jennifer&quot;</span> </code></pre>

<blockquote>Be attentive - adapter should be required before main staff. Only one adapter can be required at once.</blockquote>

<p>This should be done before you load your application configurations (or at least models). Now configuration could be loaded from yaml file:</p>

<pre><code class='language-crystal'><span class="t">Jennifer</span><span class="t">::</span><span class="t">Config</span>.read(<span class="s">&quot;./spec/fixtures/database.yml&quot;</span>, <span class="n">:development</span>) </code></pre>

<p>Second argument represents environment and just use it as namespace key grapping values from yml.</p>

<pre><code class='language-yaml'>defaults : &defaults
  host: localhost
  adapter: postgres
  user: developer
  password: 1qazxsw2
  migration_files_path: ./examples/migrations

development:
  db: jennifer_develop
  &lt;&lt;: *defaults

test:
  db: jennifer_test
  &lt;&lt;: *defaults</code></pre>

<p>Also dsl could be used:</p>

<pre><code class='language-crystal'><span class="t">Jennifer</span><span class="t">::</span><span class="t">Config</span>.configure <span class="k">do</span> <span class="o">|</span>conf<span class="o">|</span>
  conf.host <span class="o">=</span> <span class="s">&quot;localhost&quot;</span>
  conf.user <span class="o">=</span> <span class="s">&quot;root&quot;</span>
  conf.password <span class="o">=</span> <span class="s">&quot;&quot;</span>
  conf.adapter <span class="o">=</span> <span class="s">&quot;mysql&quot;</span>
  conf.db <span class="o">=</span> <span class="s">&quot;crystal&quot;</span>
  conf.migration_files_path <span class="o">=</span> <span class="s">&quot;./examples/migrations&quot;</span>
<span class="k">end</span></code></pre>

<p>All configs:</p>

<p>| config | default value |
| --- | --- |
| <code>migration_files_path</code> | <code>"./db/migrations"</code> |
| <code>structure_folder</code> | parent folder of <code>migration_files_path</code> |
| <code>host</code> | <code>"localhost"</code> |
| <code>logger</code> | <code>Logger.new(STDOUT)</code> |
| <code>schema</code> | <code>"public"</code> |
| <code>user</code> | - |
| <code>password</code> | - |
| <code>db</code> | - |
| <code>adapter</code> | - |
| <code>max_pool_size</code> | 5 |
| <code>initial_pool_size</code> | 1 |
| <code>max_idle_pool_size</code> | 1 |
| <code>retry_attempts</code> | 1 |
| <code>checkout_timeout</code> | 5.0 |
| <code>retry_delay</code> | 1.0 |</p>

<h4>Logging</h4>

<p>Jennifer uses regular Crystal logging mechanism so you could specify your own logger or formatter:</p>

<pre><code class='language-crystal'><span class="c"># Here is default logger configuration</span>
<span class="t">Jennifer</span><span class="t">::</span><span class="t">Config</span>.configure <span class="k">do</span> <span class="o">|</span>conf<span class="o">|</span>
  conf.logger <span class="o">=</span> <span class="t">Logger</span>.<span class="k">new</span>(<span class="t">STDOUT</span>)

  conf.logger.formatter <span class="o">=</span> <span class="t">Logger</span><span class="t">::</span><span class="t">Formatter</span>.<span class="k">new</span> <span class="k">do</span> <span class="o">|</span>severity, datetime, progname, message, io<span class="o">|</span>
    io <span class="o"><<</span> datetime <span class="o"><<</span> <span class="s">&quot;: &quot;</span> <span class="o"><<</span> message
  <span class="k">end</span>
  conf.logger.level <span class="o">=</span> <span class="t">Logger</span><span class="t">::</span><span class="t">DEBUG</span>
<span class="k">end</span></code></pre>

<h3>Migration</h3>

<p>For command management Jennifer now uses <a href="https://github.com/imdrasil/sam.cr" target="_blank">Sam</a>. So in your <code>sam.cr</code> just add loading migrations and Jennifer hooks.</p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;./your_configuration_folder/*&quot;</span> <span class="c"># with requiring jennifer and her adapter</span>
<span class="k">require</span> <span class="s">&quot;./migrations/*&quot;</span>
load_dependencies <span class="s">&quot;./&quot;</span>, <span class="s">&quot;jennifer&quot;</span>
<span class="c"># your another tasks here</span>
<span class="t">Sam</span>.help</code></pre>

<h4>Commands</h4>

<p>Now you can use next commands:</p>

<ul><li>create database</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:create</code></pre>

<ul><li>drop database</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:drop</code></pre>

<ul><li>run all migrations (only new ones will be run)</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:migrate</code></pre>

<ul><li>run several migrations</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:step
$ crystal sam.cr -- db:step 2</code></pre>

<ul><li>create db and run all migrations (only new ones will be run)</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:setup</code></pre>

<ul><li>rollback last migration</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:rollback</code></pre>

<ul><li>rollback <code>n</code> migrations</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:rollback n</code></pre>

<ul><li>rollback untill version <code>a</code></li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:rollback -v a</code></pre>

<ul><li>generate new migration file</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- generate:migration your_migration_name</code></pre>

<ul><li>get last migration version</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:version</code></pre>

<ul><li>load schema</li></ul>

<pre><code class='language-shell'>$ crystal sam.cr -- db:schema:load</code></pre>

<h4>Migration DSL</h4>

<p>Generator will create template file for you with next name  pattern "timestamp_your_underscored_migration_name.cr". Empty file looks like this:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">YourCamelcasedMigrationName20170119011451314</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Migration</span><span class="t">::</span><span class="t">Base</span>
  <span class="k">def</span> <span class="m">up</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="m">down</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p><code>up</code> method is needed for placing your db changes there, <code>down</code> - for reverting your changes back.</p>

<p>Regular example for creating table:</p>

<pre><code class='language-crystal'>  create_table(<span class="n">:addresses</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
    t.reference <span class="n">:contact</span> <span class="c"># creates field contact_id with Int type and allows null values</span>
    t.string <span class="n">:street</span>, {<span class="n">:size</span> => <span class="n">20</span>, <span class="n">:sql_type</span> => <span class="s">&quot;char&quot;</span>} <span class="c"># creates string field with CHAR&#40;20&#41; db type</span>
    t.bool <span class="n">:main</span>, {<span class="n">:default</span> => <span class="n">false</span>} <span class="c"># sets false as default value</span>
  <span class="k">end</span></code></pre>

<p>There are next methods which represents corresponding types:</p>

<p>| internal alias | PostgreSQL | MySql | Crystal type |
| --- | --- | --- | --- |
| <code>#integer</code> | <code>int</code> | <code>int</code> | <code>Int32</code> |
| <code>#string</code> | <code>varchar(254)</code> | <code>varchar(254)</code> | <code>String</code> |
| <code>#bool</code> | <code>boolean</code> | <code>bool</code> | <code>Bool</code> |
| <code>#char</code> | <code>char</code> | - | <code>String</code> |
| <code>#float</code> | <code>real</code> | <code>float</code> | <code>Float32</code> |
| <code>#double</code> | <code>double precision</code> | <code>double</code> | <code>Float64</code> |
| <code>#short</code> | <code>smallint</code> | <code>smallint</code> | <code>Int16</code> |
| <code>#timestamp</code> | <code>timestamp</code> | <code>timestamp</code> | <code><a href="Time.html">Time</a></code> |
| <code>#date_time</code> | <code>datetime</code> | <code>datetime</code> | <code><a href="Time.html">Time</a></code> |
| <code>#blob</code> | <code>blob</code> | <code>blob</code> | <code>Bytes</code> |
| <code>#var_string</code> | <code>varchar(254)</code> | <code>varstring</code> | <code>String</code> |
| <code>#json</code> | <code>json</code> | <code>json</code> | <code><a href="JSON/Any.html">JSON::Any</a></code> |
| <code>#enum</code> | <code>enum</code> | <code>enum</code> | <code>String</code> |</p>

<p>Also if you use postgres array types are available as well: <code>Array(Int32)</code>, <code>Array(Char)</code>, <code>Array(Float32)</code>,  <code>Array(Float64)</code>, <code>Array(Int16)</code>, <code>Array(Int32)</code>, <code>Array(Int64)</code>, <code>Array(String)</code>.</p>

<p>All of them accepts additional options:</p>

<ul><li><code>:sql_type</code> - gets exact (except size) field type;</li><li><code>:null</code> - represent nullable if field (by default is <code>false</code> for all types and field);</li><li><code>:primary</code> - marks field as primary key field (could be several ones but this provides some bugs with query generation for such model - for now try to avoid this).</li><li><code>:default</code> - default value for field</li><li><code>:auto_increment</code> - marks field to use auto increment (properly works only with <code>Int32</code> fields, another crystal types have cut functionality for it);</li><li><code>:array</code> - mark field to be array type (postgres only)</li></ul>

<p>Also there is <code>#field</code> method which allows to directly define sql type (very suitable for snums in postgres).</p>

<p>To drop table just write</p>

<pre><code class='language-crystal'>drop_table(<span class="n">:addresses</span>) <span class="c"># drops if exists</span></code></pre>

<p>To alter existing table use next methods:</p>

<ul><li><code>#change_column(name, [new_name], options)</code> - to change column definition; postgres has slighly another implementation of this than mysql one - check source code for details;</li><li><code>#add_column(name, type, options)</code> - add new column;</li><li><code>#drop_column(name)</code> - drops existing column</li><li><code>#add_index(name : String, field : Symbol, type : Symbol, order : Symbol?, length : Int32?)</code> - adds new index (postgres doesn't support length parameter and only support <code>:unique</code> type);</li><li><code>#drop_index(name : String)</code> - drops existing index;</li><li><code>#rename_table(new_name)</code> - renames table.</li></ul>

<p>Also next support methods are available:</p>

<ul><li><code>#table_exists?(name)</code></li><li><code>#index_exists?(table, name)</code></li><li><code>#column_exists?(table, name)</code></li><li><code>#data_type_exists?(name)</code> for postgres ENUM</li></ul>

<p>Here is quick example:</p>

<pre><code class='language-crystal'><span class="k">def</span> <span class="m">up</span>
  change_table(<span class="n">:contacts</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
    t.change_column(<span class="n">:age</span>, <span class="n">:short</span>, {default: <span class="n">0</span>})
    t.add_column(<span class="n">:description</span>, <span class="n">:text</span>)
    t.add_index(<span class="s">&quot;contacts_description_index&quot;</span>, <span class="n">:description</span>, <span class="k">type</span>: <span class="n">:uniq</span>, order: <span class="n">:asc</span>)
  <span class="k">end</span>

  change_table(<span class="n">:addresses</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
    t.add_column(<span class="n">:details</span>, <span class="n">:json</span>)
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="m">down</span>
  change_table(<span class="n">:contacts</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
    t.change_column(<span class="n">:age</span>, <span class="n">:integer</span>, {default: <span class="n">0</span>})
    t.drop_column(<span class="n">:description</span>)
  <span class="k">end</span>

  change_table(<span class="n">:addresses</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
    t.drop_column(<span class="n">:details</span>)
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>Also plain SQL could be executed as well:</p>

<pre><code class='language-crystal'>execute(<span class="s">&quot;ALTER TABLE addresses CHANGE street st VARCHAR&#40;20&#41;&quot;</span>)</code></pre>

<p>All changes are executed one by one so you also could add data changes here (in <code>up</code> method) but if execution of <code>up</code> method fails - <code>down</code> method will be called and all process will stop - be ready for such behavior.</p>

<p>To be sure that your db is up to date before run tests of your application, add <code><a href="Jennifer/Migration.html">Jennifer::Migration</a>::Runner.migrate</code>.</p>

<h4>Enum</h4>

<p>Now enums are supported as well but it has different implementation for adapters. For mysql is enought just write down all values:</p>

<pre><code class='language-crystal'>create_table(<span class="n">:contacts</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
  t.<span class="k">enum</span>(<span class="n">:gender</span>, values: [<span class="s">&quot;male&quot;</span>, <span class="s">&quot;female&quot;</span>])
<span class="k">end</span></code></pre>

<p>Postgres provide much more flexible and complex behaviour. Using it you need to create it firstly:</p>

<pre><code class='language-crystal'>create_enum(<span class="n">:gender_enum</span>, [<span class="s">&quot;male&quot;</span>, <span class="s">&quot;female&quot;</span>])
create_table(<span class="n">:contacts</span>) <span class="k">do</span> <span class="o">|</span>t<span class="o">|</span>
  t.string <span class="n">:name</span>, {<span class="n">:size</span> => <span class="n">30</span>}
  t.integer <span class="n">:age</span>
  t.field <span class="n">:gender</span>, <span class="n">:gender_enum</span>
  t.timestamps
<span class="k">end</span>
change_enum(<span class="n">:gender_enum</span>, {<span class="n">:add_values</span> => [<span class="s">&quot;unknown&quot;</span>]})
change_enum(<span class="n">:gender_enum</span>, {<span class="n">:rename_values</span> => [<span class="s">&quot;unknown&quot;</span>, <span class="s">&quot;other&quot;</span>]})
change_enum(<span class="n">:gender_enum</span>, {<span class="n">:remove_values</span> => [<span class="s">&quot;other&quot;</span>]})</code></pre>

<p>For more details check source code and PostgreSQL docs.</p>

<h3>Model</h3>

<p>Several model examples</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Contact</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  with_timestamps
  mapping(
    id: {<span class="k">type</span>: <span class="t">Int32</span>, primary: <span class="n">true</span>},
    name: <span class="t">String</span>,
    gender: {<span class="k">type</span>: <span class="t">String</span>, default: <span class="s">&quot;male&quot;</span>, null: <span class="n">true</span>},
    age: {<span class="k">type</span>: <span class="t">Int32</span>, default: <span class="n">10</span>},
    description: {<span class="k">type</span>: <span class="t">String</span>, null: <span class="n">true</span>},
    created_at: {<span class="k">type</span>: <span class="t">Time</span>, null: <span class="n">true</span>},
    updated_at: {<span class="k">type</span>: <span class="t">Time</span>, null: <span class="n">true</span>}
  )

  has_many <span class="n">:addresses</span>, <span class="t">Address</span>
  has_many <span class="n">:facebook_profiles</span>, <span class="t">FacebookProfile</span>
  has_and_belongs_to_many <span class="n">:countries</span>, <span class="t">Country</span>
  has_and_belongs_to_many <span class="n">:facebook_many_profiles</span>, <span class="t">FacebookProfile</span>, join_foreign: <span class="n">:profile_id</span>
  has_one <span class="n">:main_address</span>, <span class="t">Address</span>, {where { _main }}
  has_one <span class="n">:passport</span>, <span class="t">Passport</span>

  validates_inclucion <span class="n">:age</span>, <span class="n">13</span>..<span class="n">75</span>
  validates_length <span class="n">:name</span>, minimum: <span class="n">1</span>, maximum: <span class="n">15</span>
  validates_with_method <span class="n">:name_check</span>

  scope <span class="n">:main</span> { where { _age <span class="o">></span> <span class="n">18</span> } }
  scope <span class="n">:older</span> { <span class="o">|</span>age<span class="o">|</span> where { _age <span class="o">>=</span> age } }
  scope <span class="n">:ordered</span> { order(name: <span class="n">:asc</span>) }

  <span class="k">def</span> <span class="m">name_check</span>
    <span class="k">if</span> @description && @description.not_nil!.size <span class="o">></span> <span class="n">10</span>
      errors.add(<span class="n">:description</span>, <span class="s">&quot;Too large description&quot;</span>)
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Address</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  mapping(
    id: {<span class="k">type</span>: <span class="t">Int32</span>, primary: <span class="n">true</span>},
    main: <span class="t">Bool</span>,
    street: <span class="t">String</span>,
    contact_id: {<span class="k">type</span>: <span class="t">Int32</span>, null: <span class="n">true</span>},
    details: {<span class="k">type</span>: <span class="t">JSON</span><span class="t">::</span><span class="t">Any</span>, null: <span class="n">true</span>}
  )
  validates_format <span class="n">:street</span>, <span class="s">/st\.|street/</span>

  belongs_to <span class="n">:contact</span>, <span class="t">Contact</span>

  scope <span class="n">:main</span> { where { _main } }
<span class="k">end</span>

<span class="k">class</span> <span class="t">Passport</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  mapping(
    enn: {<span class="k">type</span>: <span class="t">String</span>, primary: <span class="n">true</span>},
    contact_id: {<span class="k">type</span>: <span class="t">Int32</span>, null: <span class="n">true</span>}
  )

  validates_with [<span class="t">EnnValidator</span>]
  belongs_to <span class="n">:contact</span>, <span class="t">Contact</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">Profile</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  mapping(
    id: {<span class="k">type</span>: <span class="t">Int32</span>, primary: <span class="n">true</span>},
    login: <span class="t">String</span>,
    contact_id: <span class="t">Int32</span>?,
    <span class="k">type</span>: <span class="t">String</span>
  )

  belongs_to <span class="n">:contact</span>, <span class="t">Contact</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">FacebookProfile</span> <span class="o"><</span> <span class="t">Profile</span>
  sti_mapping(
    uid: <span class="t">String</span>
  )

  has_and_belongs_to_many <span class="n">:facebook_contacts</span>, <span class="t">Contact</span>, foreign: <span class="n">:profile_id</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">TwitterProfile</span> <span class="o"><</span> <span class="t">Profile</span>
  sti_mapping(
    email: <span class="t">String</span>
  )
<span class="k">end</span>

<span class="k">class</span> <span class="t">Country</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  mapping(
    id: {<span class="k">type</span>: <span class="t">Int32</span>, primary: <span class="n">true</span>},
    name: <span class="t">String</span>
  )

  validates_exclusion <span class="n">:name</span>, [<span class="s">&quot;asd&quot;</span>, <span class="s">&quot;qwe&quot;</span>]
  validates_uniqueness <span class="n">:name</span>

  has_and_belongs_to_many <span class="n">:contacts</span>, <span class="t">Contact</span>
<span class="k">end</span></code></pre>

<p><code>mapping</code> macros stands for describing all model attributes. If field has no extra parameter, you can just specify name and type (type in case of crystal language): <code>field_name: :Type</code>. But you can use tuple and provide next parameters:</p>

<p>| argument | description |
| --- | --- |
| <code>:type</code> | crystal data type (don't use question mark - for now you can use only <code>:null</code> option) |
| <code>:primary</code> | mark field as primary key (default is <code>false</code>) |
| <code>:null</code> | allows field to be <code>nil</code> (default is <code>false</code> for all fields except primary key |
| <code>:default</code> | default value which be set during creating <strong>new</strong> object |
| <code>:getter</code> | if getter should be created (default - <code>true</code>) |
| <code>:setter</code> | if setter should be created (default - <code>true</code>) |</p>

<blockquote>By default expected that all fields are defined in model. It that is not true you should to pass `false` as second argument and override `::field_count` method to represent correct field count.</blockquote>

<p>It defines next methods:</p>

<p>| method | args | description |
| --- | --- | --- |
| <code>#initialize</code> | Hash(String \| Symbol, DB::Any), NamedTuple, MySql::ResultSet | constructors |
| <code>::field_count</code>| | number of fields |
| <code>::field_names</code>| | all fields names |
| <code>#{{field_name}}</code> | | getter |
| <code>#{{field_name}}_changed?</code> | | represents if field is changed |
| <code>#{{field_name}}!</code> | | getter with <code>not_nil!</code> if <code>null: true</code> was passed |
| <code>#{{field_name}}=</code>| | setter |
| <code>::_{{field_name}}</code> | | helper method for building queries |
| <code>#{{field_name}}_changed?</code> | | shows if field was changed |
| <code>#changed?</code> | | shows if any field was changed | 
| <code>#primary</code> | | value of primary key field |
| <code>::primary</code> | | returns criteria for primary field (query dsl) |
| <code>::primary_field_name</code> | | name of primary field |
| <code>::primary_field_type</code> | | type of primary key |
| <code>#new_record?</code> | | returns <code>true</code> if record has <code>nil</code> primary key (is not stored to db) |
| <code>::create</code> | <code>Hash(String \| Symbol, DB::Any)</code>, <code>NamedTuple</code> | creates object, stores it to db and returns it |
| <code>::create!</code> | <code>Hash(String \| Symbol, DB::Any)</code>, <code>NamedTuple</code> | creates object, stores it to db and returns it; otherwise raise exception |
| <code>::build</code> | <code>Hash(String \| Symbol, DB::Any), NamedTuple</code> | builds object |
| <code>::create</code> | <code>Hash(String \| Symbol, DB::Any)</code>, <code>NamedTuple</code> | builds object from hash and saves it to db with all callbacks |
| <code>::create!</code> | <code>Hash(String \| Symbol, DB::Any)</code>, <code>NamedTuple</code> | builds object from hash and saves it to db with callbacks or raise exception |
| <code>#save</code> | | saves object to db; returns <code>true</code> if success and <code>false</code> elsewhere |
| <code>#save!</code> | | saves object to db; returns <code>true</code> if success or rise exception otherwise |
| <code>#to_h</code> | | returns hash with all attributes |
| <code>#to_str_h</code> | | same as <code>#to_h</code> but with String keys |
| <code>#attribute</code> | <code>String \| Symbol</code> | returns attribute value by it's name |
| <code>#attributes_hash</code> | | returns <code>to_h</code> with deleted <code>nil</code> entries |
| <code>#changed?</code> | | check if any field was changed |
| <code>#set_attribute</code> | <code>String \| Symbol</code>, <code>DB::Any</code> | sets attribute by given name |
| <code>#attribute</code> | <code>String \| Symbol</code> | returns attribute value by it's name |</p>

<p>Automatically model is associated with table with underscored pluralized class name, but special name can be defined using <code>::table_name</code> method in own body before using any relation (<code>::singular_table_name</code> - for singular variant).</p>

<h4>STI</h4>

<p>Singl table inheritance could be used in next way:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Profile</span> <span class="o"><</span> <span class="t">Jennifer</span><span class="t">::</span><span class="t">Model</span><span class="t">::</span><span class="t">Base</span>
  mapping(
    id: {<span class="k">type</span>: <span class="t">Int32</span>, primary: <span class="n">true</span>},
    login: <span class="t">String</span>,
    contact_id: <span class="t">Int32</span>?,
    <span class="k">type</span>: <span class="t">String</span>
  )

  belongs_to <span class="n">:contact</span>, <span class="t">Contact</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">FacebookProfile</span> <span class="o"><</span> <span class="t">Profile</span>
  sti_mapping(
    uid: <span class="t">String</span>
  )

  has_and_belongs_to_many <span class="n">:facebook_contacts</span>, <span class="t">Contact</span>, foreign: <span class="n">:profile_id</span>
<span class="k">end</span>

<span class="k">class</span> <span class="t">TwitterProfile</span> <span class="o"><</span> <span class="t">Profile</span>
  sti_mapping(
    email: <span class="t">String</span>
  )
<span class="k">end</span></code></pre>

<p>Subclass extends superclass definition with new fields and use string fild <code>type</code> to indentify itself.</p>

<blockquote>Now `Profile.all` will return objects of `Profile` class not taking into account `type` field and will raise exception of even zomby process if superclass doesn't override `::field_count`.</blockquote>

<h4>Prepared queries (scopes)</h4>

<p>Also you can specify prepared query statement.</p>

<pre><code class='language-crystal'>scope <span class="n">:query_name</span> { where { c(<span class="s">&quot;some_field&quot;</span>) <span class="o">></span> <span class="n">10</span> } }
scope <span class="n">:query_with_arguments</span> { <span class="o">|</span>a, b<span class="o">|</span> where { (c(<span class="s">&quot;f1&quot;</span>) <span class="o">==</span> a) && (c(<span class="s">&quot;f2&quot;</span>).<span class="k">in</span>(b) } }</code></pre>

<p>As you can see arguments are next:</p>

<ul><li>scope (query) name</li><li>block to be executed in query contex (any query part could be passed: join, where, having, etc.)</li></ul>

<p>Also they are chainable, so you could do:</p>

<pre><code class='language-crystal'><span class="t">ModelName</span>.all.where { _some_field <span class="o">></span> <span class="n">1</span> }
         .query_with_arguments(<span class="s">&quot;done&quot;</span>, [<span class="n">1</span>,<span class="n">2</span>])
         .order(f1: <span class="n">:asc</span>).no_argument_query</code></pre>

<h4>Relations</h4>

<p>There are 4 types of relations: has_many, has_and_belongs_to_many, belongs_to and has_one. All of them have same semantic but generate slightly different methods.</p>

<p>They takes next arguments:</p>

<ul><li>relation name</li><li>target class</li><li><code>request</code> - additional request (will be used inside of where clause) - optional</li><li><code>foreign</code> - name of foreign key - optional; by default use singularized table name + "_id"</li><li><code>primary</code> - primary field name - optional;  by default it uses default primary field of class.</li></ul>

<p>has_and_belongs_to_many also accepts next 2 arguments and use regular arguments silghtly in another way:</p>

<ul><li><code>join_table</code> - join table name; be default relation table names in alphabetic order joined by underscore is used</li><li><code>join_foreign</code> - foreign key for current model (left foreign key of join table)</li><li><code>foreign</code> - used as right foreign key</li><li><code>primary</code> - used as primary field of current table; for now it properly works only if both models in this relation has primary field named <code>id</code></li></ul>

<p>All relation macroses provide next methods:</p>

<ul><li><code>#{{relation_name}}</code> - cache relation object (or array of them) and returns it;</li><li><code>#{{relation_name}}_reload</code> - reload relation and returns it;</li><li><code>#{{relation_name}}_query</code> - returns query which is used to get objects of this object relation entities form db.</li><li><code>#remove_{{relation_name}}</code> - removes given object from relation</li><li><code>#add_{{relation_name}}</code> - adds given object to relation or builds it from has and adds</li></ul>

<p>This allows dynamically adds objects to relations with automacially settting foreign id:</p>

<pre><code class='language-crystal'>contact <span class="o">=</span> <span class="t">Contact</span>.all.find!
contact.add_addresses({<span class="n">:main</span> => <span class="n">true</span>, <span class="n">:street</span> => <span class="s">&quot;some street&quot;</span>, <span class="n">:details</span> => <span class="n">nil</span>})

address <span class="o">=</span> contact.addresses.last
contact.remove_addresses(address)</code></pre>

<p><code>belongs_to</code> and <code>has_one</code> add extra method <code>#relation_name!</code> which also adds assertion for <code>nil</code>.</p>

<h4>Validations</h4>

<p>For validation purposes is used <a href="https://github.com/neovintage/accord" target="_blank">accord</a> shard. Also there are several general macrosses for declaring validations:</p>

<ul><li><code>validates_with_method(*names)</code> - accepts method name/names</li><li><code>validates_inclusion(field, value)</code> - checks if <code>value</code> includes <code>@{{field}}</code></li><li><code>validates_exclusion(field, value)</code> - checks if <code>value</code> excludes <code>@{{field}}</code></li><li><code>validates_format(field, format)</code> - checks if <code>{{format}}</code> matches <code>@{{field}}</code></li><li><code>validates_length(field, **options)</code> - check <code>@{{field}}</code> size; allowed options are: <code>:in</code>, <code>:is</code>, <code>:maximum</code>, <code>:minimum</code></li><li><code>validates_uniqueness(field)</code> - check if <code>@{{field}}</code> is unique</li></ul>

<p>If record is not valid it will not be saved.</p>

<h4>Callbacks</h4>

<p>There are next macrosses for defining callbacks:</p>

<ul><li><code>before_save</code></li><li><code>after_save</code></li><li><code>before_create</code></li><li><code>after_create</code></li><li><code>after_initialize</code></li><li><code>before_destroy</code></li></ul>

<p>They accept method names.</p>

<h4>Timestamps</h4>

<p><code>with_timestamps</code> macros adds callbacks for <code>created_at</code> and <code>updated_at</code> fields update.</p>

<h4>Destroy</h4>

<p>To destroy object use <code>#delete</code> (is called withoud callback) or <code>#destroy</code>. To destroy several objects by their ids use class method:</p>

<pre><code class='language-crystal'>ids <span class="o">=</span> [<span class="n">1</span>, <span class="n">20</span>, <span class="n">18</span>]
<span class="t">Contact</span>.destroy(ids)
<span class="t">Address</span>.delete(<span class="n">1</span>)
<span class="t">Country</span>.delete(<span class="n">1</span>,<span class="n">2</span>,<span class="n">3</span>)</code></pre>

<h4>Update</h4>

<p>There are several ways which allows to update object. Some of them were mentioned in mapping section. There are few extra methods to do this:</p>

<ul><li><code>#update_column(name, value)</code> - sets directly attribute and store it to db without any callback</li><li><code>#update_columns(values)</code> - same for several ones</li><li><code>#update_attributes(values)</code> - just set attributes</li><li><code>#set_attribute(name, value)</code> - set attribute by given name</li></ul>

<h3>Query DSL</h3>

<p>My favorite part. Jennifer allows you to build lazy evaluated queries with chaining syntax. But some of them could be only at the and of a chain (such as <code>#fisrt</code> or <code>#pluck</code>). Here is a list of all dsl methods:</p>

<h4>Find</h4>

<p>Object could be retrieved by id using <code>find</code> (returns <code>T?</code>) and <code>find!</code> (returns <code>T</code> or raise <code>RecordNotFound</code> exception) methods.</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.find!(<span class="n">1</span>)</code></pre>

<h4>Where</h4>

<p><code>all</code> retrieves everything (only at the beginning; creates empty request)</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all</code></pre>

<p>Specifying where clause is really flexible. Method accepts block which represents where clause of request (or it's part - you can chain several <code>where</code> and they will be concatenated using <code>AND</code>).</p>

<p>To specify field use <code>c</code> method which accepts string as field name. As I've mentioned after declaring model attributes, you can use their names inside of block: <code>_field_name</code> if it is for current table and <code>ModelName._field_name</code> if for another model. Also there you can specify attribute of some model or table using underscores: <code>_some_model_or_table_name__field_name</code> - model/table name is separated from field name by "__". You can specify relation in space of which you want to declare condition using double _ at the beginning and block. Several examples:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.where { c(<span class="s">&quot;id&quot;</span>) <span class="o">==</span> <span class="n">1</span> }
<span class="t">Contact</span>.where { _id <span class="o">==</span> <span class="n">1</span> }
<span class="t">Contact</span>.all.join(<span class="t">Address</span>) { <span class="t">Contact</span>._id <span class="o">==</span> _contact_id }
<span class="t">Contact</span>.all.relation(<span class="n">:addresses</span>).where { __addresses { _id <span class="o">></span> <span class="n">1</span> } } </code></pre>

<p>Also you can use <code>primary</code> to mention primary field:</p>

<pre><code class='language-crystal'><span class="t">Passport</span>.where { primary.like(<span class="s">&quot;&#37;123&#37;&quot;</span>) }</code></pre>

<p>Supported operators:</p>

<p>| Operator | SQL variant |
| --- | --- |
| <code>==</code> | <code>=</code> |
| <code>!=</code> |<code>!=</code> |
| <code><</code> |<code><</code> |
| <code><=</code> |<code><=</code> |
| <code>></code> |<code>></code> |
| <code>>=</code> |<code>>=</code> |
| <code>=~</code> | <code>REGEXP</code>, <code>~</code> |
| <code>&</code> | <code>AND</code> |
| <code>|</code> | <code>OR</code> |</p>

<p>And operator-like methods:</p>

<p>| Method | SQL variant |
| --- | --- |
| <code>regexp</code> | <code>REGEXP</code>, <code>~</code> (accepts <code>String</code>) |
| <code>not_regexp</code> |<code>NOT REGEXP</code> |
| <code>like</code> | <code>LIKE</code> |
| <code>not_like</code> | <code>NOT LIKE</code> |
| <code>is</code> | <code>IS</code> and provided value |
| <code>not</code> | <code>NOT</code> and provided value (or as unary operator if no one is given) |
| <code>in</code> | <code>IN</code> |</p>

<p>And postgres specific:</p>

<p>| Method | SQL variant |
| --- | --- |
| <code>contain</code> | <code>@></code> |
| <code>contained</code> |<code><@</code> |
| <code>overlap</code> | <code>&&</code> |</p>

<p>To specify exact sql query use <code>#sql</code> method:</p>

<pre><code class='language-crystal'><span class="c"># it behaves like regular criteria</span>
<span class="t">Contact</span>.all.where { sql(<span class="s">&quot;age &gt; ?&quot;</span>,  [<span class="n">15</span>]) <span class="o">&</span> (_name <span class="o">==</span> <span class="s">&quot;Stephan&quot;</span>) } </code></pre>

<p>Query will be inserted "as is". Usage of <code>#sql</code> allows to use nested plain request.</p>

<p><strong>Tips</strong></p>

<ul><li>all regexp methods accepts string representation of regexp</li><li>use parenthesis for binary operators (<code>&</code> and <code>|</code>)</li><li><code>nil</code> given to <code>!=</code> and <code>==</code> will be transformed to <code>IS NOT NULL</code> and <code>IS NULL</code></li><li><code>is</code> and <code>not</code> operator accepts next values: <code>:nil</code>, <code>nil</code>, <code>:unknown</code>, <code>true</code>, <code>false</code></li></ul>

<p>At the end - several examples:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.where { (_id <span class="o">></span> <span class="n">40</span>) <span class="o">&</span> _name.regexp(<span class="s">&quot;^&#91;a-d&#93;&quot;</span>) }

<span class="t">Address</span>.where { _contact_id.is(<span class="n">nil</span>) }</code></pre>

<h4>Select</h4>

<p>Raw sql for <code>SELECT</code> clause could be passed into <code>#select</code> method. This have highest priority during forming this query part.</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.select(<span class="s">&quot;COUNT&#40;id&#41; as count, contacts.name&quot;</span>).group(<span class="s">&quot;name&quot;</span>)
       .having { sql(<span class="s">&quot;COUNT&#40;id&#41;&quot;</span>) <span class="o">></span> <span class="n">1</span> }.pluck(<span class="n">:name</span>)</code></pre>

<h4>From</h4>

<p>Also you can provide subquery to specify FROM clause (but be carefull with source fields during result retriving and mapping to objects)</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.from(<span class="s">&quot;select * from contacts where id &gt; 2&quot;</span>)
<span class="t">Contacts</span>.all.from(<span class="t">Contact</span>.where { _id <span class="o">></span> <span class="n">2</span> })</code></pre>

<h4>Delete and Destroy</h4>

<p>For now they both are the same - creates delete query with given conditions. <code>destroy</code> firstly loads objects and run callbacks and then calls delete on each.</p>

<p>It can be only at the end of chain.</p>

<pre><code class='language-crystal'><span class="t">Address</span>.where { _main.not }.delete</code></pre>

<h4>Joins</h4>

<p>To join another table you can use <code>join</code> method passing model class or table name (<code>String</code>) and join type (default is <code>:inner</code>).</p>

<pre><code class='language-crystal'>field <span class="o">=</span> <span class="s">&quot;contact_id&quot;</span>
table <span class="o">=</span> <span class="s">&quot;passports&quot;</span>
<span class="t">Contact</span>.all.join(<span class="t">Address</span>) { <span class="t">Contact</span>._id <span class="o">==</span> _contact_id }.join(table) { c(field) <span class="o">==</span> _id }</code></pre>

<p>Query, built inside of block, will passed to <code>ON</code> section of <code>JOIN</code>. Current context of block is joined table.</p>

<p>Also there is two shortcuts for left and right joins:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.left_join(<span class="t">Address</span>) { _contacts__id <span class="o">==</span> _contact_id }
<span class="t">Contact</span>.all.right_join(<span class="s">&quot;addresses&quot;</span>) { _contacts__id <span class="o">==</span> c(<span class="s">&quot;contact_id&quot;</span>) }</code></pre>

<blockquote>For now Jennifer provide manual aliasing as second argument for `#join` and automatic when using `#includes` and `#with` methods. For details check out the code. </blockquote>

<h4>Relation</h4>

<p>To join model relation (has_many, belongs_to and has_one) pass it's name and join type:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.relation(<span class="s">&quot;addresses&quot;</span>).relation(<span class="n">:passport</span>, <span class="k">type</span>: <span class="n">:left</span>)</code></pre>

<h4>Includes</h4>

<p>To preload some relation use <code>includes</code> and pass relation name:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.includes(<span class="s">&quot;addresses&quot;</span>)</code></pre>

<p>If there are several includes with same table - Jennifer will auto alias tables.</p>

<h4>Group</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.group(<span class="s">&quot;name&quot;</span>, <span class="s">&quot;id&quot;</span>).pluck(<span class="n">:name</span>, <span class="n">:id</span>)</code></pre>

<p><code>#group</code> allows to add columns for <code>GROUP BY</code> section. If passing arguments are tuple of strings or just one string - all columns will be parsed as current table columns. If there is a need to group on joined table or using fields from several tables use next:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.relation(<span class="s">&quot;addresses&quot;</span>).group(addresses: [<span class="s">&quot;street&quot;</span>], contacts: [<span class="s">&quot;name&quot;</span>])
       .pluck(<span class="s">&quot;addresses.street&quot;</span>, <span class="s">&quot;contacts.name&quot;</span>)</code></pre>

<p>Here keys should be <em>table names</em>.</p>

<h4>Having</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.group(<span class="s">&quot;name&quot;</span>).having { _age <span class="o">></span> <span class="n">15</span> }</code></pre>

<p><code>#having</code> allows to add <code>HAVING</code> part of query. It accepts block same way as <code>#where</code> does.</p>

<h4>Exists</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.where { _age <span class="o">></span> <span class="n">42</span> }.exists? <span class="c"># returns true or false</span></code></pre>

<p><code>#exists?</code> check is there is any record with provided conditions. Can be only at the end of query chain - it hit the db.</p>

<h4>Distinct</h4>

<pre><code class='language-crystal'><span class="t">Contant</span>.all.distinct(<span class="s">&quot;age&quot;</span>) <span class="c"># returns array of ages &#40;Array&#40;DB::Any | Int16 | Int8&#41;&#41;</span></code></pre>

<p><code>#distinct</code> retrieves from db column values without repeats. Can accept column name and as optional second parameter - table name. Can be only as at he end of call chain - hit the db.</p>

<h4>Aggregation</h4>

<p>There are 2 types of aggregation functions: ones which are orking without GROUP clause and returns single values (e.g. <code>max</code>, <code>min</code>, <code>count</code>) and ones, working with GROUP clause and returning array of values.</p>

<h4>Max</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.max(<span class="n">:name</span>, <span class="t">String</span>)</code></pre>

<h4>Min</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.min(<span class="n">:age</span>, <span class="t">Int32</span>)</code></pre>

<h4>Avg</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.avg(<span class="n">:age</span>, <span class="t">Float64</span>) <span class="c"># mysql specific</span>
<span class="t">Contact</span>.all.avg(<span class="n">:age</span>, <span class="t">PG</span><span class="t">::</span><span class="t">Numeric</span>) <span class="c"># Postgres specific</span></code></pre>

<h4>Sum</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.sum(<span class="n">:age</span>, <span class="t">Float64</span>) <span class="c"># mysql specific</span>
<span class="t">Contact</span>.all.sum(<span class="n">:age</span>, <span class="t">Int64</span>) <span class="c"># postgre specific</span></code></pre>

<h4>Count</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.count</code></pre>

<h4>Group Max</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.group(<span class="n">:gender</span>).group_max(<span class="n">:age</span>, <span class="t">Int32</span>)</code></pre>

<h4>Group Min</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.group(<span class="n">:gender</span>).group_min(<span class="n">:age</span>, <span class="t">Int32</span>)</code></pre>

<h4>Group Avg</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.avg(<span class="n">:age</span>, <span class="t">Float64</span>) <span class="c"># mysql specific</span>
<span class="t">Contact</span>.all.avg(<span class="n">:age</span>, <span class="t">PG</span><span class="t">::</span><span class="t">Numeric</span>) <span class="c"># Postgres specific</span></code></pre>

<h4>Group Sum</h4>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.group(<span class="n">:gender</span>).group_sum(<span class="n">:age</span>, <span class="t">Float64</span>) <span class="c"># mysql specific</span>
<span class="t">Contact</span>.all.group(<span class="n">:gender</span>).group_sum(<span class="n">:age</span>, <span class="t">Int64</span>) <span class="c"># postgre specific</span></code></pre>

<h4>Pagination</h4>

<p>For now you can only specify <code>limit</code> and <code>offset</code>:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.limit(<span class="n">10</span>).offset(<span class="n">10</span>)</code></pre>

<h4>Order</h4>

<p>You can specifies orders to sort:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.order(name: <span class="n">:asc</span>, id: <span class="s">&quot;desc&quot;</span>)</code></pre>

<p>It accepts hash as well.</p>

<h4>Update</h4>

<p>You can provide hash or named tuple with new field values:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.update(age: <span class="n">1</span>, name: <span class="s">&quot;Wonder&quot;</span>)</code></pre>

<p>Will not trigers any callback.</p>

<h4>Eager load</h4>

<p>As was said Jennifer provide lazy query evaluation  so it will be performed only after trying to access to element from collection (any array method - it implements Enumerable). Also you can extract first entity via <code>first</code>. If you are sure that at least one entity in db satisfies you query you can call <code>#first!</code>.</p>

<p>To extract only some fields rather then entire objects use <code>pluck</code>:</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.pluck(<span class="n">:id</span>, <span class="s">&quot;name&quot;</span>)</code></pre>

<p>It returns array of values if only one field was given and array of arrays if more. It accepts raw sql arguments so be care when using this with joining tables with same field names. But this allows to retrieve some custom data from specified select clause.</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.select(<span class="s">&quot;COUNT&#40;id&#41; as count, contacts.name&quot;</span>).group(<span class="s">&quot;name&quot;</span>)
       .having { sql(<span class="s">&quot;COUNT&#40;id&#41;&quot;</span>) <span class="o">></span> <span class="n">1</span> }.pluck(<span class="n">:count</span>)</code></pre>

<p>To load relations using same query joins needed tables (yep you should specify join on condition by yourself again) and specifies all needed relations in <code>with</code> (relation name not table).</p>

<pre><code class='language-crystal'><span class="t">Contact</span>.all.left_join(<span class="t">Address</span>) { _contacts__id <span class="o">==</span> _contact_id }.<span class="k">with</span>(<span class="n">:addresses</span>)</code></pre>

<h4>Transaction</h4>

<p>Transaction mechanism provides block-like syntax:</p>

<pre><code class='language-crystal'><span class="t">Jennifer</span><span class="t">::</span><span class="t">Adapter</span>.adapter.transaction <span class="k">do</span> <span class="o">|</span>tx<span class="o">|</span>
  <span class="t">Contact</span>.create({<span class="n">:name</span> => <span class="s">&quot;Chose&quot;</span>, <span class="n">:age</span> => <span class="n">20</span>})
<span class="k">end</span></code></pre>

<p>If any error was raised in block transaction will be rollbacked. To rollback transaction raise <code>DB::Rollback</code> exception.</p>

<p>Transaction lock connection for current fiber avoiding grepping new one from pool.</p>

<h4>Truncation</h4>

<p>To truncate entire table use:</p>

<pre><code class='language-crystal'><span class="t">Jennifer</span><span class="t">::</span><span class="t">Adapter</span>.adapter.truncate(<span class="s">&quot;contacts&quot;</span>)
<span class="c"># or</span>
<span class="t">Jennifer</span><span class="t">::</span><span class="t">Adapter</span>.adapter.truncate(<span class="t">Contact</span>)</code></pre>

<p>This functionality could be useful to clear db between test cases.</p>

<h3>Important restrictions</h3>

<ul><li>sqlite3 has a lot of limitations so it's support will be added not soon</li></ul>

<h3>Test</h3>

<p>The fastest way to rollback all changes in DB after test case - transaction. So add:</p>

<pre><code class='language-crystal'><span class="t">Spec</span>.before_each <span class="k">do</span>
  <span class="t">Jennifer</span><span class="t">::</span><span class="t">Adapter</span>.adapter.begin_transaction
<span class="k">end</span>

<span class="t">Spec</span>.after_each <span class="k">do</span>
  <span class="t">Jennifer</span><span class="t">::</span><span class="t">Adapter</span>.adapter.rollback_transaction
<span class="k">end</span></code></pre>

<p>to your <code>spec_helper.cr</code>. Also just regular deleting or truncation could be used but transaction provide 15x speed up (at least for postgres; mysql gets less impact).</p>

<blockquote>This functions can be safely used only under test environment.</blockquote>

<h2>Development</h2>

<p>There are still a lot of work to do. Tasks for next versions:</p>

<ul><li>[ ] add SQLite support</li><li>[ ] increase test coverage to acceptable level</li><li>[ ] add json operators</li><li>[ ] add possibility for <code>#group</code> accept any sql string</li><li>[ ] add polymorphic associations</li><li>[ ] add through to relations</li><li>[ ] add subquery support</li><li>[ ] add join table option for all relations</li><li>[ ] refactor many-to-many relation</li><li>[ ] add seeds</li><li>[ ] rewrite tests to use minitest</li><li>[ ] add self documentation</li><li>[ ] add views support (materialized as well)</li></ul>

<p>Before development create db user (information is in /spec/config.cr file), run</p>

<pre><code class='language-shell'>$ crystal example/migrate.cr -- db:setup</code></pre>

<p>Support both MySql and PostgreSQL are critical. By default postgres are turned on. To run tests with mysql use next:</p>

<pre><code class='language-shell'>$ DB=mysql crystal spec</code></pre>

<h2>Documentation</h2>

<p>I try to keep current README with uptodate information. Self documentation is not fully support yet but you can compile docs using shell script:</p>

<pre><code class='language-shell'>$ ./generate-docs.sh</code></pre>

<p>It also depends on choosed adapter (postgres is by default).</p>

<h2>Contributing</h2>

<ol><li><a href=" https://github.com/imdrasil/jennifer.cr/fork " target="_blank">Fork it</a></li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<p>Please ask me before starting work on smth.</p>

<p>Also if you want to use it in your application (for now shard is almost ready for use in production) - ping me please, my email you can find in my profile.</p>

<p>To run tests use regular <code>crystal spec</code>. All migrations is under <code>./examples/migrations</code> directory.</p>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/imdrasil" target="_blank">imdrasil</a> Roman Kalnytskyi - creator, maintainer</li></ul>
</div>
</body>
</html>
