<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 0.30.1">


<link href="css/style.css" rel="stylesheet" type="text/css">

<script type="text/javascript" src="js/doc.js"></script>
<script type="text/javascript">
  CrystalDoc.base_path = "";
</script>

  <meta id="repository-name" content="github.com/imdrasil/hermes.cr">
  <title>README - github.com/imdrasil/hermes.cr</title>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="repository-links">
      <a href="index.html">README</a>
    </div>
  </div>

  <div class="search-results" class="hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="github.com/imdrasil/hermes.cr/Hermes" data-name="hermes">
      <a href="Hermes.html">Hermes</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/AggregationResponse" data-name="hermes::aggregationresponse">
      <a href="Hermes/AggregationResponse.html">AggregationResponse</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Client" data-name="hermes::client">
      <a href="Hermes/Client.html">Client</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Cluster" data-name="hermes::cluster">
      <a href="Hermes/Cluster.html">Cluster</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Config" data-name="hermes::config">
      <a href="Hermes/Config.html">Config</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Hit" data-name="hermes::hit(t)">
      <a href="Hermes/Hit.html">Hit</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Hits" data-name="hermes::hits(t)">
      <a href="Hermes/Hits.html">Hits</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/hermes.cr/Hermes/Index" data-name="hermes::index">
      <a href="Hermes/Index.html">Index</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Index/OptionValue" data-name="hermes::index::optionvalue">
      <a href="Hermes/Index/OptionValue.html">OptionValue</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/MultiGetResponse" data-name="hermes::multigetresponse(t)">
      <a href="Hermes/MultiGetResponse.html">MultiGetResponse</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/hermes.cr/Hermes/Persistent" data-name="hermes::persistent">
      <a href="Hermes/Persistent.html">Persistent</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Persistent/Any" data-name="hermes::persistent::any">
      <a href="Hermes/Persistent/Any.html">Any</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Repository" data-name="hermes::repository(i, t)">
      <a href="Hermes/Repository.html">Repository</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Response" data-name="hermes::response">
      <a href="Hermes/Response.html">Response</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/SearchResponse" data-name="hermes::searchresponse(t)">
      <a href="Hermes/SearchResponse.html">SearchResponse</a>
      
    </li>
  
  <li class="parent " data-id="github.com/imdrasil/hermes.cr/Hermes/Types" data-name="hermes::types">
      <a href="Hermes/Types.html">Types</a>
      
        <ul>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Binary" data-name="hermes::types::binary">
      <a href="Hermes/Types/Binary.html">Binary</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Circle" data-name="hermes::types::circle">
      <a href="Hermes/Types/Circle.html">Circle</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Envelope" data-name="hermes::types::envelope">
      <a href="Hermes/Types/Envelope.html">Envelope</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/GeometryCollection" data-name="hermes::types::geometrycollection">
      <a href="Hermes/Types/GeometryCollection.html">GeometryCollection</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/GeoPoint" data-name="hermes::types::geopoint">
      <a href="Hermes/Types/GeoPoint.html">GeoPoint</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/GeoShape" data-name="hermes::types::geoshape">
      <a href="Hermes/Types/GeoShape.html">GeoShape</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/IGeoShape" data-name="hermes::types::igeoshape">
      <a href="Hermes/Types/IGeoShape.html">IGeoShape</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/IP" data-name="hermes::types::ip">
      <a href="Hermes/Types/IP.html">IP</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/LineString" data-name="hermes::types::linestring">
      <a href="Hermes/Types/LineString.html">LineString</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/MultiLineString" data-name="hermes::types::multilinestring">
      <a href="Hermes/Types/MultiLineString.html">MultiLineString</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/MultiPoint" data-name="hermes::types::multipoint">
      <a href="Hermes/Types/MultiPoint.html">MultiPoint</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/MultiPolygon" data-name="hermes::types::multipolygon">
      <a href="Hermes/Types/MultiPolygon.html">MultiPolygon</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Point" data-name="hermes::types::point">
      <a href="Hermes/Types/Point.html">Point</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Polygon" data-name="hermes::types::polygon">
      <a href="Hermes/Types/Polygon.html">Polygon</a>
      
    </li>
  
  <li class=" " data-id="github.com/imdrasil/hermes.cr/Hermes/Types/Range" data-name="hermes::types::range(t)">
      <a href="Hermes/Types/Range.html">Range</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1>Hermes <a href="https://travis-ci.org/imdrasil/hermes.cr" target="_blank"><img src="https://travis-ci.org/imdrasil/hermes.cr.svg?branch=master" alt="Build Status"/></a></h1>

<p>This is an integration of Crystal and Elasticsearch via HTTP/HTTPS protocol.</p>

<h2>Installation</h2>

<p>Add this to your application's <code>shard.yml</code>:</p>

<pre><code class="language-yaml">dependencies:
  hermes:
    github: imdrasil/hermes.cr</code></pre>

<h2>Usage</h2>

<h3>Configuration</h3>

<p>Put</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;hermes&quot;</span></code></pre>

<p>in places where you load your configurations. For now you need to specify all configurations using dsl but in future support of yaml configuration files for different environments will be added. So this is regular configuration for playground environment:</p>

<pre><code class="language-crystal"><span class="t">Hermes</span><span class="t">::</span><span class="t">Config</span>.configure <span class="k">do</span> <span class="o">|</span>conf<span class="o">|</span>
  conf.host <span class="o">=</span> <span class="s">&quot;localhost&quot;</span>
  conf.port <span class="o">=</span> <span class="n">9200</span>
<span class="k">end</span></code></pre>

<p>Default values:</p>

<p>| attribute | value |
| --- | --- |
| <code>host</code> | <code>"localhost"</code> |
| <code>port</code>| <code>9200</code> |
| <code>schema</code> | <code>"http"</code> |</p>

<h3>Command management</h3>

<p>For command management Hermes uses <a href="https://github.com/imdrasil/sam.cr" target="_blank">Sam</a>. So in your <code>sam.cr</code> just add loading migrations and Jennifer hooks.</p>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;./your_configuration_folder/*&quot;</span>
load_dependencies <span class="s">&quot;./&quot;</span>, <span class="s">&quot;hermes&quot;</span>
<span class="c"># your another tasks here</span>
<span class="t">Sam</span>.help</code></pre>

<h4>Commands</h4>

<p>Now you can use next commands:</p>

<ul><li>put all mappings to Elasticsearch</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:mapping:update</code></pre>

<ul><li>updates configurations of all indexes</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:update_all</code></pre>

<ul><li>creates all indexes</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:create_all</code></pre>

<ul><li>updates configuration of provided index</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:update index_name</code></pre>

<ul><li>creates given index</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:create index_name</code></pre>

<ul><li>destroy given index</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:destroy index_name</code></pre>

<ul><li>destroy all indexes</li></ul>

<pre><code class="language-shell">$ crystal sam.cr -- es:index:destroy_all</code></pre>

<h3>Index</h3>

<p>First of all specify all your indexes. Here is example of some test index:</p>

<pre><code class="language-crystal"><span class="k">class</span> <span class="t">TestIndex</span> <span class="o">&lt;</span> <span class="t">Hermes</span><span class="t">::</span><span class="t">Index</span>
  index_name <span class="s">&quot;test_index&quot;</span>

  config({
    mappings: {
      post: {
        properties: {
          title: {
            <span class="k">type</span>:   <span class="s">&quot;text&quot;</span>,
            fields: {
              raw: {
                <span class="k">type</span>: <span class="s">&quot;keyword&quot;</span>,
              },
            },
          },
          likes:      {<span class="k">type</span>: <span class="s">&quot;integer&quot;</span>},
          user:       {<span class="n">:type</span> => <span class="s">&quot;text&quot;</span>},
          text:       {<span class="n">:type</span> => <span class="s">&quot;text&quot;</span>},
          tag:        {<span class="n">:type</span> => <span class="s">&quot;keyword&quot;</span>},
          created_at: {<span class="n">:type</span> => <span class="s">&quot;date&quot;</span>},
        },
      },

      user: {
        properties: {
          full_name: {<span class="k">type</span>: <span class="s">&quot;text&quot;</span>},
          location:  {<span class="k">type</span>: <span class="s">&quot;geo_point&quot;</span>},
          photo:     {<span class="k">type</span>: <span class="s">&quot;binary&quot;</span>},
        },
      },
    },
  })
<span class="k">end</span></code></pre>

<blockquote>You could use both <code>NamedTuple</code> and hash notation</blockquote>

<p><code>config</code> macros allows you specify configs for index (settings, mappings, etc.). Here regular Elasticsearch options should be used.</p>

<p>Also using <code>index_name</code> method custom index name could be stored. By default underscored class name without last "_index" part is taken.</p>

<h3>Repository</h3>

<p>Hermes implements some kind of Datamapper pattern so all CRUD and search logic will be inside of repository which allows to separate search and domain logic. So regular repository looks like this:</p>

<pre><code class="language-crystal"><span class="k">class</span> <span class="t">PostRepository</span> <span class="o">&lt;</span> <span class="t">Hermes</span><span class="t">::</span><span class="t">Repository</span>(<span class="t">TestIndex</span>, <span class="t">Post</span>)
<span class="k">end</span></code></pre>

<p>By default repository name is underscored class name without last "_repository" part. But it can be specified using <code>document_type</code> method.</p>

<h3>Persistent</h3>

<p>This is module which includes mapping rules for fields. This allows to mix it into any class. Here is simple example:</p>

<pre><code class="language-crystal"><span class="k">class</span> <span class="t">Post</span>
  <span class="k">include</span> <span class="t">Hermes</span><span class="t">::</span><span class="t">Persistent</span>

  es_fields(
    title: <span class="t">String</span>,
    likes: {<span class="k">type</span>: <span class="t">Int32</span>, default: <span class="n">0</span>},
    user: <span class="t">String</span>,
    text: <span class="t">String</span>,
    tag: {<span class="k">type</span>: <span class="t">String</span>, nilable: <span class="n">true</span>},
    created_at: <span class="t">Time</span> <span class="o">|</span> <span class="t">Nil</span>,
    non_existing_field: {<span class="k">type</span>: <span class="t">Int32</span> <span class="o">|</span> <span class="t">Nil</span>, nilable: <span class="n">true</span>}
  )
<span class="k">end</span></code></pre>

<p><code>es_fields</code> macros works almost same way as <code>JSON.mapping</code> except generating several extra methods:</p>

<ul><li><code>#{{attribute_name}}!</code> - for all given attributes with getters; makes not nil assertion</li><li><code>#initialize(Hash(String, Any))</code></li><li><code>#initialize(Hash(Symbol, Any))</code></li><li><code>#initialize(**)</code></li><li><code>#assign_es_fields(Hash)</code> - will set all given fields</li><li><code>#assign_es_fields(**)</code></li><li><code>#to_hash</code> - returns hash with all attributes (keys are strings)</li></ul>

<h4>Data types</h4>

<p>All regular Crystal data types, which could be mapped from Elasticsearch data types, are supported (like <code>Int32</code>, <code>String</code> or <code>Times</code>, or <code>Array(Int32)</code>). Also supported all "special" data types:</p>

<ul><li>binary (<code><a href="Hermes/Types/Binary.html">Hermes::Types::Binary</a></code>)</li><li>range (<code><a href="Hermes/Types/Range.html">Hermes::Types::Range</a>(T)</code>)</li></ul>

<p>> Due to Elasticsearch documentation there are several supported data types: <code>Int32</code>, <code>Int64</code>, <code>Float32</code> <code>Float64</code>, <code>Time</code>.</p>

<ul><li>IP address (<code><a href="Hermes/Types/IP.html">Hermes::Types::IP</a></code>)</li><li>geometrical</li><ul><li>geo_point (<code><a href="Hermes/Types/GeoPoint.html">Hermes::Types::GeoPoint</a></code>)</li><li>circle (<code><a href="Hermes/Types/Circle.html">Hermes::Types::Circle</a></code>)</li><li>envelope (<code>Hermes::Types::Envelop</code>)</li><li>geometry collection (<code><a href="Hermes/Types/GeometryCollection.html">Hermes::Types::GeometryCollection</a></code>)</li><li>line string (<code><a href="Hermes/Types/LineString.html">Hermes::Types::LineString</a></code>)</li><li>multi line string (<code><a href="Hermes/Types/MultiLineString.html">Hermes::Types::MultiLineString</a></code>)</li><li>multi point (<code><a href="Hermes/Types/MultiPoint.html">Hermes::Types::MultiPoint</a></code>)</li><li>multi polygon (<code><a href="Hermes/Types/MultiPolygon.html">Hermes::Types::MultiPolygon</a></code>)</li><li>point (<code><a href="Hermes/Types/Point.html">Hermes::Types::Point</a></code>)</li><li>polygon (<code><a href="Hermes/Types/Polygon.html">Hermes::Types::Polygon</a></code>)</li></ul></ul>

<h3>CRUD</h3>

<h4>Create</h4>

<p>New object can be created from Hash (with string keys), NamedTuple or new Persistent object.</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.create({<span class="s">&quot;user&quot;</span> => <span class="s">&quot;kim&quot;</span>, <span class="s">&quot;message&quot;</span> => <span class="s">&quot;some message&quot;</span>, <span class="s">&quot;tag&quot;</span> => <span class="s">&quot;es&quot;</span>, <span class="s">&quot;time&quot;</span> => <span class="t">Time</span>.now })

<span class="t">PostRepository</span>.create(user: <span class="s">&quot;eddy&quot;</span>, message: <span class="s">&quot;some message&quot;</span>, tag: <span class="s">&quot;es&quot;</span>, time: <span class="t">Time</span>.now )

obj <span class="o">=</span> <span class="t">Post</span>.<span class="k">new</span>({<span class="s">&quot;user&quot;</span> => <span class="s">&quot;kim&quot;</span>, <span class="s">&quot;message&quot;</span> => <span class="s">&quot;some message&quot;</span>, <span class="s">&quot;tag&quot;</span> => <span class="s">&quot;es&quot;</span>, <span class="s">&quot;time&quot;</span> => <span class="t">Time</span>.now })
<span class="t">PostRepository</span>.save(obj)</code></pre>

<p>Due to Elasticsearch documentations, new object will be indexed in several seconds. So to do it immediatly you can manualy refresh:</p>

<pre><code class="language-crystal"><span class="t">TestIndex</span>.refresh
<span class="c"># or passing true as second parameter for #save</span>

<span class="t">PostRepository</span>.save(obj, <span class="n">true</span>)</code></pre>

<p>Such usage could slow down everything.</p>

<h4>Read</h4>

<p>Single document can be retrieved by it's id:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.find(<span class="s">&quot;elastic_uid_here&quot;</span>) <span class="c"># object or nil</span>
<span class="t">PostRepository</span>.find!(<span class="s">&quot;elastic_uid_here&quot;</span>) <span class="c"># object or exception</span>
<span class="t">PostRepository</span>.multi_get([<span class="s">&quot;uid1&quot;</span>, <span class="s">&quot;uid2&quot;</span>]) <span class="c"># array of found objects by their ids</span>
<span class="t">PostRepository</span>.all</code></pre>

<p>Also regular Elasticsearch query dsl could be used:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.search({
    query: {
        bool: {
            must: {
                term: {user: <span class="s">&quot;kim&quot;</span>},
            },
            should: [
                {term: {tag: <span class="s">&quot;wow&quot;</span>}},
                {term: {tag: <span class="s">&quot;es&quot;</span>}},
            ],
            minimum_should_match: <span class="n">1</span>,
            boost:                <span class="n">1.0</span>,
        },
    },
})</code></pre>

<p>It will return <code>SearchResponse(T)</code> object (in this case <code>T</code> is a <code>Post</code>). It provide access to all response data and has shortcuts for search and aggregation results (<code>entries</code> and <code>aggs</code> methods).</p>

<p>If you need only count of matched objects:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.count({
    query: {
        bool: {
            must: {
                term: {user: <span class="s">&quot;kim&quot;</span>},
            },
            should: [
                {term: {tag: <span class="s">&quot;wow&quot;</span>}},
                {term: {tag: <span class="s">&quot;es&quot;</span>}},
            ],
            minimum_should_match: <span class="n">1</span>,
            boost:                <span class="n">1.0</span>,
        },
    },
}) <span class="c"># some Int32 value</span></code></pre>

<p>Also there is shortcut for aggregations:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.aggregate({max_date: {max: {field: <span class="s">&quot;time&quot;</span>}}})</code></pre>

<p>It will return object of <code>SearchResponse(T)</code> as well as <code>search</code> but without entries inside.</p>

<h4>Update</h4>

<p>If you want to save new version of object, use regular same:</p>

<pre><code class="language-crystal">obj.message <span class="o">=</span> <span class="s">&quot;another message&quot;</span>
<span class="t">PostRepository</span>.save(obj)</code></pre>

<p>Also there is method for <code>_update</code> Elasticsearch endpoint:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.update(<span class="s">&quot;some_id&quot;</span>, { script: {...}}) <span class="c"># allow specify entire request body</span>

<span class="t">PostRepository</span>.update_doc(<span class="s">&quot;some_id&quot;</span>, {user: <span class="s">&quot;tomas&quot;</span>}) <span class="c"># accepts &quot;doc&quot; part of body</span>

<span class="t">PostRepository</span>.update_by_script(<span class="s">&quot;some_id&quot;</span>, {
  script: {
    inline: <span class="s">&quot;ctx._source.likes += params.count&quot;</span>,
    lang:   <span class="s">&quot;painless&quot;</span>,
    params: {count: <span class="n">1</span>},
  },
}) <span class="c"># allow specify entire request body</span></code></pre>

<p>and <code>_update_by_query</code></p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.update_by_query({
  script: {
    inline: <span class="s">&quot;ctx._source.likes += params.count&quot;</span>,
    lang:   <span class="s">&quot;painless&quot;</span>,
    params: {count: <span class="n">1</span>},
  },
  query: {
    term: {
      user: <span class="s">&quot;kim&quot;</span>,
    },
  },
})</code></pre>

<h4>Delete</h4>

<p>To delete object by it's id use:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.delete(obj._id)</code></pre>

<p>Also you can do it using query:</p>

<pre><code class="language-crystal"><span class="t">PostRepository</span>.delete_by_query({query: {match: {message: <span class="s">&quot;some message&quot;</span>}}})</code></pre>

<h2>Restrictions</h2>

<p>Hermes uses one connection and is needed to be tested with multi-threading (check safety).</p>

<h2>Development</h2>

<p>There are still a lot of work to do. Tasks for next versions:</p>

<ul><li>[ ] fully cover with tests</li><li>[ ] add IP related logic to <code><a href="Hermes/Types/IP.html">Hermes::Types::IP</a></code> and move it to separate shard (like <a href="https://github.com/deploy2/ruby-ip" target="_blank">ruby-ip</a>)</li><li>[ ] think about adding smth like <a href="https://github.com/ysbaddaden/pool" target="_blank">connection pool</a></li><li>[ ] add <a href="https://github.com/imdrasil/jennifer.cr" target="_blank">Jennifer</a> support</li><li>[ ] add more things below...</li></ul>

<h2>Contributing</h2>

<ol><li><a href="https://github.com/imdrasil/hermes.cr/fork " target="_blank">Fork it</a></li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<p>Please ask me before start any work on some feature.</p>

<p>Also if you want to use it in your application - ping me please, my email could be found in my profile.</p>

<p>To run test use regular <code>crystal spec</code>.</p>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/imdrasil" target="_blank">imdrasil</a> Roman Kalnytskyi - creator, maintainer</li></ul>
</div>
</body>
</html>
