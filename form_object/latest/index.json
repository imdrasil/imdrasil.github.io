{"repository_name":"github.com/imdrasil/form_object","body":"# FormObject [![Build Status](https://travis-ci.org/imdrasil/form_object.svg)](https://travis-ci.org/imdrasil/form_object) [![Latest Release](https://img.shields.io/github/release/imdrasil/form_object.svg)](https://github.com/imdrasil/form_object/releases) [![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](https://imdrasil.github.io/form_object/versions)\n\nThis shard gives you an opportunity to separate form data from your model. Also you can move ny data-specific validation to form object level and be free from coercing data from the request instance - it will take care of it.\n\n> ATM FormObject is designed to be used in air with [Jennifer](https://github.com/imdrasil/jennifer.cr) ORM but can be also used as ORM-agnostic tool but with some limitations.\n\n## Installation\n\nAdd this to your application's `shard.yml`:\n\n```yaml\ndependencies:\n  form_object:\n    github: imdrasil/form_object\n```\n\n## Usage\n\nRequire FromObject somewhere after Jennifer:\n\n```crystal\nrequire \"jennifer\"\n# ...\nrequire \"form_object\"\nrequire \"form_object/coercer/pg\" # if you are going to use PG::Numeric\n```\n\nAlso it is important to notice that `form_object` modifies `HTTP::Request` core class to store body in private variable `@cached_body : IO::Memory?` of maximum size 1 GB. This is done because to allow request body multiple reading.\n\n### Defining Form\n\nForms are defined in the separate classes. Often (but not necessary) these classes are pretty similar to related models:\n\n```crystal\nclass PostForm < FormObject::Base(Post)\n  attr :title, String\nend\n```\n\nUse `.attr` macro to define a field.\n\nAlso you can specify [any validation](https://github.com/imdrasil/jennifer.cr/blob/master/docs/validation.md) supported by Jennifer model.\n\n```crystal\nclass PostForm < FormObject::Base(Post)\n  attr :title, String\n\n  validates_length :title, in: 1...255\nend\n\nf = PostForm.new(Post.new)\nf.title = \"a\" * 255\nf.valid? # false\nf.errors # Jennifer::Model::Errors\n```\n\nResource model translation messages are used for the form.\n\n#### Nesting\n\nTo define nested object use `.object` macro:\n\n```crystal\nclass AddressForm < FormObject::Base(Address)\n  attr :street, Address\nend\n\nclass ContactForm < FormObject::Base(Contact)\n  object :address, Address\nend\n```\n\nFor collection use `.collection` macro.\n\n##### Populators\n\nIn `#verify`, nested hash is passed. Form object by default will try to match nested hashes to the nested forms. But sometimes the incoming hash and the existing object graph are not matching 1-to-1. That's where populators will help you.\n\nYou have to declare a populator when the form has to deserialize nested input. ATM populator may be only a method name.\n\nPopulator is called only if an incoming part for particular object is present.\n\n```crystal\n# request with { addresses: [{ :street => \"Some street\" }]} payload\nform.verify(request) # will call populator once\n# request with { addresses: [] of String} payload\nform.verify(request) # will not call populator\n```\n\nPopulator for collection is executed for every collection part in the incoming hash.\n\n```crystal\nclass ContactForm < FormObject::Base(Contact)\n  collection :addresses, Address, populator: :address_populator\n\n  def address_populator(collection, index, **opts)\n    if item = collection[index]?\n      item\n    else\n      item = AddressForm.new(Address.new({contact_id: resource.id}))\n      collection << item\n      item\n    end\n  end\n```\n\nThis populator checks if a nested form is already existing by using `collection[index]?`. While the `index` argument represents where we are in the incoming array traversal, `collection` is identical to `self.addresses`.\n\nIt is very important that each populator invocation returns the *form* not the model.\n\n##### Delete\n\nPopulators can not only create, but also destroy. Let's say the following input is passed in.\n\n```crystal\n# request with the { addresses: [{:street => \"Street\", :id => 2, :_delete => \"1\" }] } payload\nform.verify(request)\n```\n\nYou can implement your own deletion:\n\n```crystal\nclass ContactForm < FormObject::Base(Contact)\n  collection :addresses, Address, populator: :address_populator\n\n  property ids_to_destroy : Array(Int32)\n\n  def address_populator(context, **opts)\n    item = addresses.find { |address| address.id == context[\"id\"] }\n\n    if context[\"_delete\"]\n      addresses.delete(item)\n      ids_to_destroy << item.id\n      skip\n    end\n\n    if item\n      item\n    else\n      item = AddressForm.new(Address.new)\n      collection << item\n      item\n    end\n  end\n\n  def persist\n    super.tap do |result|\n      next unless result\n      ids = ids_to_destroy\n      Address.where { _id.in(ids) }.destroy\n    end\n  end\nend\n```\n\n##### Skip\n\nPopulators can skip processing of a part by invoking `#skip`. This method raises `FormObject::SkipException` which makes form object to ignore particular part.\n\n#### Reusability\n\nTo reuse common attributes or functionality you can use modules inclusion and inheritance:\n\n```crystal\nmodule PostTitle\n  include FormObject::Module\n\n  attr :title, String\nend\n\nmodule PostText\n  include FormObject::Module\n\n  attr :text, String\nend\n\nmodule BasePostAttributes\n  include PostTitle\n  include PostText\nend\n\nclass PostForm < FormObject::Base(Post)\n  include BasePostAttributes\n\n  attr :release_date, Time\n\n  validates_length :title, in: 1...255\nend\n\nclass AdvancedPostForm < PostForm\n  attr :likes, Int32\nend\n```\n\n### Create Form\n\n```crystal\nclass PostsController < ApplicationController\n  def edit\n    @form = PostForm.new(Post.find!(params[\"id\"]))\n    render(\"edit.slang\")\n  end\nend\n```\n\nForm will automatically read attributes from the model.\n\n### Validation\n\nTo save model you should validate input data:\n\n```crystal\nclass PostsController < ApplicationController\n  def create\n    @form = PostForm.new(Post.new)\n    if @form.verify(request) && @form.save\n      flash[\"success\"] = \"Created Post successfully.\"\n      redirect_to \"/posts\"\n    else\n      flash[\"danger\"] = \"Could not create Post!\"\n      render(\"new.slang\")\n    end\n  end\nend\n```\n\nThe `#verify` method parses data from the given request object and updates form attributes - the underlying model at this step remains unchanged. Next if runs defined validations and returns whether they succeed.\n\n### Data Synching\n\nAfter validation you can call `#save` (as in example above) and let FormObject take care of model persistence. Also you can use `#sync` to only write attributes from form to the resource and do everything else by your own.\n\n#### Custom Persistence Mechanism\n\nYou can define your own way of model persistence at the form level implementing own `#persist` method:\n\n```crystal\nclass PostForm < FormObject::Base(Post)\n  attr :title, String\n\n  def persist\n    resource.save\n    # some other logic goes here\n  end\nend\n```\n\n## Contributing\n\n1. Fork it (<https://github.com/imdrasil/form_object/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n> FormObject is heavily inspired by [reform](https://github.com/trailblazer/reform) ruby gem.\n\n- [imdrasil](https://github.com/imdrasil) Roman Kalnytskyi - creator, maintainer\n","program":{"html_id":"github.com/imdrasil/form_object/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/imdrasil/form_object","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}}