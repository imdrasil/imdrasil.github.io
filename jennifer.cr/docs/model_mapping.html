<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Imdrasil Homebrew Stuff | Personal site</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Imdrasil Homebrew Stuff" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Personal site" />
<meta property="og:description" content="Personal site" />
<link rel="canonical" href="https://imdrasil.github.io/jennifer.cr/docs/model_mapping.html" />
<meta property="og:url" content="https://imdrasil.github.io/jennifer.cr/docs/model_mapping.html" />
<meta property="og:site_name" content="Imdrasil Homebrew Stuff" />
<script type="application/ld+json">
{"description":"Personal site","@type":"WebPage","url":"https://imdrasil.github.io/jennifer.cr/docs/model_mapping.html","headline":"Imdrasil Homebrew Stuff","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://imdrasil.github.io/feed.xml" title="Imdrasil Homebrew Stuff" /></head>
<body><header class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Imdrasil Homebrew Stuff</a>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    <header class="site-header" role="banner">
  <div class="wrapper">
    <nav class="site-nav">
      <div class="trigger">
        
          <a class="page-link" href="./callbacks">Callbacks</a>
        
          <a class="page-link" href="./model_sti">STI</a>
        
          <a class="page-link" href="./timestamps">Timestamps</a>
        
          <a class="page-link" href="./eager_loading">Eager Loading</a>
        
          <a class="page-link" href="./getting_started">Getting started</a>
        
          <a class="page-link" href="./validation">Validation</a>
        
          <a class="page-link" href="./query_dsl">Query DSL</a>
        
          <a class="page-link" href="./configuration">Configuration</a>
        
          <a class="page-link" href="./index">Jennifer Documentation</a>
        
          <a class="page-link" href="./model_mapping">Mapping</a>
        
          <a class="page-link" href="./view">Views</a>
        
          <a class="page-link" href="./transaction_and_lock">Transaction &amp; Lock</a>
        
          <a class="page-link" href="./time">Time</a>
        
          <a class="page-link" href="./internationalization">Internationalization</a>
        
          <a class="page-link" href="./record">Record</a>
        
          <a class="page-link" href="./migration">Migration</a>
        
          <a class="page-link" href="./pagination_and_ordering">Pagination &amp; Ordering</a>
        
          <a class="page-link" href="./relations">Relations</a>
        
          <a class="page-link" href="./crud">CRUD</a>
        
          <a class="page-link" href="./aggregation">Aggregations</a>
        
          <a class="page-link" href="./authentication">Authentication</a>
        
          <a class="page-link" href="./command_line">Command Line</a>
        
          <a class="page-link" href="./model_scopes">Scopes</a>
        
      </div>
    </nav>
  </div>
</header>

<h1 id="mapping">Mapping</h1>

<p>Several model examples</p>

<pre><code class="language-crystal">class Contact &lt; Jennifer::Model::Base
  with_timestamps
  mapping(
    id: Primary32, # same as {type: Int32, primary: true}
    name: String,
    gender: {type: String?, default: "male"},
    age: {type: Int32, default: 10},
    description: String?,
    created_at: Time?,
    updated_at: Time | Nil
  )

  has_many :addresses, Address
  has_many :facebook_profiles, FacebookProfile
  has_and_belongs_to_many :countries, Country
  has_and_belongs_to_many :facebook_many_profiles, FacebookProfile, join_foreign: :profile_id
  has_one :main_address, Address, {where { _main }}
  has_one :passport, Passport

  validates_inclusion :age, 13..75
  validates_length :name, minimum: 1, maximum: 15
  validates_with_method :name_check

  scope :main { where { _age &gt; 18 } }
  scope :older { |age| where { _age &gt;= age } }
  scope :ordered { order(name: :asc) }

  def name_check
    if @description &amp;&amp; @description.not_nil!.size &gt; 10
      errors.add(:description, "Too large description")
    end
  end
end

class Address &lt; Jennifer::Model::Base
  mapping(
    id: {type: Int32, primary: true},
    main: Bool,
    street: String,
    contact_id: Int32?,
    details: JSON::Any?
  )
  validates_format :street, /st\.|street/

  belongs_to :contact, Contact

  scope :main { where { _main } }
end

class Passport &lt; Jennifer::Model::Base
  mapping(
    enn: {type: String, primary: true},
    contact_id: {type: Int32, null: true}
  )

  validates_with EnnValidator
  belongs_to :contact, Contact
end

class Profile &lt; Jennifer::Model::Base
  mapping(
    id: Primary32,
    login: String,
    contact_id: Int32?,
    type: String
  )

  belongs_to :contact, Contact
end

class FacebookProfile &lt; Profile
  mapping(
    uid: String
  )

  has_and_belongs_to_many :facebook_contacts, Contact, foreign: :profile_id
end

class TwitterProfile &lt; Profile
  mapping(
    email: String
  )
end

class Country &lt; Jennifer::Model::Base
  mapping(
    id: Primary32,
    name: String
  )

  validates_exclusion :name, ["asd", "qwe"]
  validates_uniqueness :name

  has_and_belongs_to_many :contacts, Contact
end
</code></pre>

<h2 id="mapping-definition">Mapping definition</h2>

<p>You should define all fields that you’d like to grep from the particular table, other words - define model’s mapping.</p>

<p><code class="highlighter-rouge">%mapping(options, strict = true)</code> macro stands for defining all model attributes. If field has no extra parameter,
you can just specify name and type (type in case of crystal language): <code class="highlighter-rouge">field_name: :Type</code>. Named tuple can be used
instead of type. Next keys are supported:</p>

<table>
  <thead>
    <tr>
      <th>argument</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">:type</code></td>
      <td>crystal data type</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:primary</code></td>
      <td>mark field as primary key (default is <code class="highlighter-rouge">false</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:null</code></td>
      <td>allows field to be <code class="highlighter-rouge">nil</code> (default is <code class="highlighter-rouge">false</code> for all fields except primary key</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:default</code></td>
      <td>default value which will be set during creating <strong>new</strong> object</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:column</code></td>
      <td>database column name associated with this attribute (default is attribute name)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:getter</code></td>
      <td>if getter should be created (default - <code class="highlighter-rouge">true</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:setter</code></td>
      <td>if setter should be created (default - <code class="highlighter-rouge">true</code>)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:virtual</code></td>
      <td>mark field as virtual - will not be stored and retrieved from db</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:converter</code></td>
      <td>class be used to serialize/deserialize value</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">:auto</code></td>
      <td>indicate whether primary field is autoincrementable (by default <code class="highlighter-rouge">true</code> for <code class="highlighter-rouge">Int32</code> and <code class="highlighter-rouge">Int64</code>)</td>
    </tr>
  </tbody>
</table>

<p>To define field converter create a class which implements next methods:</p>

<ul>
  <li><code class="highlighter-rouge">.from_db(DB::ResultSet, Bool)</code> - converts field reading it from db result set (second argument describes if field is nillable);</li>
  <li><code class="highlighter-rouge">.to_db(SomeType)</code> - converts field to the db format;</li>
  <li><code class="highlighter-rouge">.from_hash(Hash(String, Jennifer::DBAny), String)</code> - converts field from the given hash (second argument is a field name).</li>
</ul>

<p>There are 2 predefined converters:</p>

<ul>
  <li><code class="highlighter-rouge">Jennifer::Model::JSONConverter</code> - default converter for <code class="highlighter-rouge">JSON::Any</code>;</li>
  <li><code class="highlighter-rouge">Jennifer::Model::NumericToFloat64Converter</code> - converts Postgres <code class="highlighter-rouge">PG::Numeric</code> to <code class="highlighter-rouge">Float64</code>.</li>
</ul>

<p>To make some field nillable tou can use any of the next options:</p>

<ul>
  <li>pass <code class="highlighter-rouge">null: true</code> option to the named tuple</li>
  <li>use <code class="highlighter-rouge">?</code> in type declaration (e.g. <code class="highlighter-rouge">some_field: String?</code> or <code class="highlighter-rouge">some_filed: {type: String?}</code>)</li>
  <li>use union with <code class="highlighter-rouge">Nil</code> in the type declaration (e.g. <code class="highlighter-rouge">some_field: String | Nil</code> or <code class="highlighter-rouge">some_filed: {type: String | Nil}</code>)</li>
</ul>

<p>If you don’t want to define all the table fields - pass <code class="highlighter-rouge">false</code> as second argument (this will disable default strict mapping mode).</p>

<p><code class="highlighter-rouge">%mapping</code> defines next methods:</p>

<table>
  <thead>
    <tr>
      <th>method</th>
      <th>args</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">#initialize</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any), NamedTuple, MySql::ResultSet</code></td>
      <td>constructors</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::field_count</code></td>
      <td> </td>
      <td>number of fields</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::field_names</code></td>
      <td> </td>
      <td>all fields names</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#{{field_name}}</code></td>
      <td> </td>
      <td>getter</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#{{field_name}}_changed?</code></td>
      <td> </td>
      <td>presents whether field is changed</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#{{field_name}}!</code></td>
      <td> </td>
      <td>getter with <code class="highlighter-rouge">not_nil!</code> if <code class="highlighter-rouge">null: true</code> was passed</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#{{field_name}}=</code></td>
      <td> </td>
      <td>setter</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::_{{field_name}}</code></td>
      <td> </td>
      <td>helper method for building queries</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#{{field_name}}_changed?</code></td>
      <td> </td>
      <td>shows if field was changed</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#changed?</code></td>
      <td> </td>
      <td>shows if any field was changed</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#primary</code></td>
      <td> </td>
      <td>value of primary key field</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::primary</code></td>
      <td> </td>
      <td>returns criterion for primary field (query DSL)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::primary_field_name</code></td>
      <td> </td>
      <td>name of primary field</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::primary_field_type</code></td>
      <td> </td>
      <td>type of primary key</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#new_record?</code></td>
      <td> </td>
      <td>returns <code class="highlighter-rouge">true</code> if record has <code class="highlighter-rouge">nil</code> primary key (is not stored to db)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::create</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any)</code>, <code class="highlighter-rouge">NamedTuple</code></td>
      <td>creates object, stores it to db and returns it</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::create!</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any)</code>, <code class="highlighter-rouge">NamedTuple</code></td>
      <td>creates object, stores it to db and returns it; otherwise raise exception</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::build</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any), NamedTuple</code></td>
      <td>builds object</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::create</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any)</code>, <code class="highlighter-rouge">NamedTuple</code></td>
      <td>builds object from hash and saves it to db with all callbacks</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">::create!</code></td>
      <td><code class="highlighter-rouge">Hash(String \| Symbol, DB::Any)</code>, <code class="highlighter-rouge">NamedTuple</code></td>
      <td>builds object from hash and saves it to db with callbacks or raise exception</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#save</code></td>
      <td> </td>
      <td>saves object to db; returns <code class="highlighter-rouge">true</code> if success and <code class="highlighter-rouge">false</code> elsewhere</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#save!</code></td>
      <td> </td>
      <td>saves object to db; returns <code class="highlighter-rouge">true</code> if success or rise exception otherwise</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#to_h</code></td>
      <td> </td>
      <td>returns hash with all attributes</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#to_str_h</code></td>
      <td> </td>
      <td>same as <code class="highlighter-rouge">#to_h</code> but with String keys</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#attribute</code></td>
      <td><code class="highlighter-rouge">String \| Symbol</code></td>
      <td>returns attribute value by it’s name</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#changed?</code></td>
      <td> </td>
      <td>check if any field was changed</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#set_attribute</code></td>
      <td><code class="highlighter-rouge">String \| Symbol</code>, <code class="highlighter-rouge">DB::Any</code></td>
      <td>sets attribute by given name</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">#attribute</code></td>
      <td><code class="highlighter-rouge">String \| Symbol</code></td>
      <td>returns attribute value by it’s name</td>
    </tr>
  </tbody>
</table>

<p>Also <code class="highlighter-rouge">#{{field_name}}?</code> predicate method for the case when it is boolean.</p>

<p>All allowed types are listed on the <a href="https://imdrasil.github.io/jennifer.cr/docs/migration">Migration</a> page.</p>

<p>All defined mapping properties are accessible via <code class="highlighter-rouge">COLUMNS_METADATA</code> constant and <code class="highlighter-rouge">::columns_tuple</code> method.</p>

<p>It may be useful to have one parent class for all your models - just make it abstract and everything will work well:</p>

<pre><code class="language-crystal">abstract class ApplicationRecord &lt; Jennifer::Model::Base
end

class SomeModel &lt; ApplicationRecord
  mapping(
    id: Int32,
    name: String
  )
end
</code></pre>

<p><strong>Important restrictions:</strong></p>

<ul>
  <li>
    <p>Models currently must have a <code class="highlighter-rouge">primary</code> field.</p>
  </li>
  <li>
    <p>If your model also uses <code class="highlighter-rouge">JSON.mapping</code>, <code class="highlighter-rouge">JSON::Serializable</code>, or other kinds of mapping macros, you must be careful
to use Jennifer’s <code class="highlighter-rouge">mapping</code> macro last in order for all model features to work correctly.</p>
  </li>
</ul>

<pre><code class="language-crystal">class User &lt; Jennifer::Model::Base
  # JSON.mapping used *before* model mapping:
  JSON.mapping(id: Int32, name: String)

  # Model mapping used last:
  mapping(id: Primary32, name: String)
end
</code></pre>

<h3 id="mapping-types">Mapping Types</h3>

<p>Jennifer has built-in system of predefined options for some usage. They are not data types on language level (you can’t defined variable of <code class="highlighter-rouge">Primary32</code> type) and can be used only in mapping definition (standard usage).</p>

<pre><code class="language-crystal">class Post &lt; Jennifer::Model::Base
  mapping(
    id: Primary32,
    # or even with full definition
    pk: { type: Primary32, primary: false, virtual: true }
  )
end
</code></pre>

<p>All overrides from full definition will be respected and used instead of predefined for such a type.</p>

<p>To defined your own type define it such a way it may be lexically accessible from place you want to use it:</p>

<pre><code class="language-crystal">class ApplicationRecord &lt; Jennifer::Model::Base
  EmptyString = {
    type: String,
    default: ""
  }

  {% TYPES &lt;&lt; "EmptyString" %}
  # or if this is outside of model or view scope
  {% ::Jennifer::Macros::TYPES &lt;&lt; "EmptyString" %}
end
</code></pre>

<blockquote>
  <p>Obviously, registered type added to the <code class="highlighter-rouge">TYPES</code> should be the same as defined constant; also it should be stringified.</p>
</blockquote>

<p>Existing mapping types:</p>

<ul>
  <li><code class="highlighter-rouge">Primary32 = { type: Int32, primary: true }</code></li>
  <li><code class="highlighter-rouge">Primary64 = { type: Int64, primary: true }</code></li>
  <li><code class="highlighter-rouge">Password = { type: String?, virtual: true, setter: false }</code></li>
</ul>

<h3 id="numeric-fields">Numeric fields</h3>

<p>Crystal type of a numeric (decimal) field depends on chosen adapter: <code class="highlighter-rouge">Float64</code> for mysql and <code class="highlighter-rouge">PG::Numeric</code> for Postgres. Sometimes usage of <code class="highlighter-rouge">PG::Numeric</code> with Postgres may be annoying. To convert it to another type at the object building stage you can pass <code class="highlighter-rouge">numeric_converter</code> option with method to be used to convert <code class="highlighter-rouge">PG::Numeric</code> to the defined field <code class="highlighter-rouge">type</code>.</p>

<pre><code class="language-crystal">class Product &lt; Jennifer::Model::Base
  mapping(
    id: Primary32,
    #...
    price: { type: Float64, numeric_converter: :to_f64 }
  )
end
</code></pre>

<h2 id="table-name">Table name</h2>

<p>Automatically model is associated with table with underscored pluralized name of it’s class, but custom one can be specified defining <code class="highlighter-rouge">::table_name</code>. This means no modules will affect name generating.</p>

<pre><code class="language-crystal">Admin::User.table_name # "users"
</code></pre>

<p>To provide special table prefix per module basis use super class with defined <code class="highlighter-rouge">::table_prefix</code> method:</p>

<pre><code class="language-crystal">module Admin
  class Base &lt; Jennifer::Model::Base
    def self.table_prefix
      "admin_"
    end
  end

  class User &lt; Base
    mapping(id: Primary32)
  end
end

Admin::User.table_name # "admin_users"
</code></pre>

<h2 id="virtual-attributes">Virtual attributes</h2>

<p>If you pass <code class="highlighter-rouge">virtual: true</code> option for some field - it will not be stored to db and tried to be retrieved from there. Such behavior is useful if you have model-level attributes but it is not obvious to store them into db. Such approach allows mass assignment and dynamic get/set based on their name.</p>

<pre><code class="language-crystal">class User &lt; Jennifer::Model::Base
  mapping(
    id: Primary32,
    password_hash: String,
    password: { type: String?, virtual: true },
    password_confirmation: { type: String?, virtual: true }
  )

  validate_confirmation :password

  before_create :crypt_password

  def crypt_password
    self.password_hash = SomeCryptAlgorithm.call(self.password)
  end
end

User.create!(password: "qwe", password_confirmation: "qwe")
</code></pre>

<h2 id="converting-form-web-options">Converting form Web options</h2>

<p>In the Web world all data got submitted forms will be recognized as <code class="highlighter-rouge">Hash(String, String)</code> which is not acceptable by your models. To resolve this use <a href="https://github.com/imdrasil/form_object">form_object</a> shard.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Imdrasil Homebrew Stuff</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Imdrasil Homebrew Stuff</li><li><a class="u-email" href="mailto:moranibaca@gmail.com">moranibaca@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/imdrasil"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">imdrasil</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Personal site</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
